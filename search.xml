<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[layui完美分页，ajax请求分页（真分页） 【2.0版本】]]></title>
    <url>%2F2017%2F10%2F25%2Flayui-page-2.0%2F</url>
    <content type="text"><![CDATA[注意使用的layui版本为：layui-v2.0以上版本，如果v1.0版本请看我另外一篇博客 《layui完美分页，ajax请求分页（真分页）》 最近因为以为学者在看了我上一篇关于layui分页的博客遇到了问题，原因是因为使用了新版本2.x，导致有一些属性改变了，所以出了这篇新版本的博客，本文是根据上一篇博客改变而成，如有疑问请联系我 email：1085143002@qq.com 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;link rel="icon" href="static/images/titleLogo.png" /&gt; &lt;title&gt;门店管理后台&lt;/title&gt; &lt;link rel="stylesheet" href="static/layui/plugins/layui/css/layui.css" media="all" /&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="static/css/reset.css"&gt; &lt;link rel="stylesheet" type="text/css" href="static/css/commend.css"&gt; --&gt; &lt;!-- &lt;link rel="stylesheet" href="static/css/jqpagination.css" /&gt; --&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="static/css/shopCustomerManager.css"&gt; --&gt; &lt;script type="text/javascript" src="static/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="static/layui/plugins/layui/layui.js"&gt;&lt;/script&gt; &lt;!-- &lt;script type="text/javascript" src="static/js/jquery.jqpagination.js"&gt;&lt;/script&gt; --&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; //ajax请求后台数据 getShopCustomerManagePageInfo(); //点击搜索时 搜索数据 $("#selectButton").click(function()&#123; getShopCustomerManagePageInfo(); currentPageAllAppoint = 1; //当点击搜索的时候，应该回到第一页 toPage();//然后进行分页的初始化 &#125;) toPage(); &#125;); //分页参数设置 这些全局变量关系到分页的功能 var startAllAppoint = 0;//开始页数 var limitAllAppoint = 10;//每页显示数据条数 var currentPageAllAppoint = 1;//当前页数 var dataLength = 0;//数据总条数 //ajax请求后台数据 function getShopCustomerManagePageInfo()&#123; $.ajax(&#123; type:"post", async:false, url:"list_shop_customers_info", data:&#123;start:startAllAppoint, limit:limitAllAppoint,selectValue:$("#selectValue").val()&#125;, success:function(data,status)&#123; data=eval("("+data+")"); getShopCustomesInfo(data.root); startAllAppoint = data.currentResult;//当前页数(后台返回) dataLength = data.total;//数据总条数 &#125; &#125;); &#125; function getShopCustomesInfo(data)&#123; var s = "&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;电话&lt;/th&gt;&lt;th&gt;备案楼盘&lt;/th&gt;&lt;th&gt;已成交&lt;/th&gt;&lt;th&gt;归属经纪人&lt;/th&gt;&lt;th&gt;添加时间&lt;/th&gt;&lt;/tr&gt;"; $.each(data,function(v,o)&#123; s+='&lt;tr&gt;&lt;td&gt;'+o.cusName+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.cusSex+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.phone+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.records+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.alreadyDeal+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.theMedi+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.addTime+'&lt;/td&gt;&lt;/tr&gt;'; &#125;); if(data.length&gt;0)&#123; $("#t_customerInfo").html(s); &#125;else&#123; $("#page1").hide(); $("#t_customerInfo").html("&lt;br/&gt;&lt;span style='width:10%;height:30px;display:block;margin:0 auto;'&gt;暂无数据&lt;/span&gt;"); &#125; &#125; function toPage()&#123; layui.use(['form', 'laypage', 'layedit','layer', 'laydate'], function() &#123; var form = layui.form(), layer = layui.layer, layedit = layui.layedit, laydate = layui.laydate, laypage = layui.laypage; var nums = 10; //调用分页 laypage(&#123; cont: 'paged' ,count: dataLength //这个是后台返回的数据的总条数 ,limit: limitAllAppoint //每页显示的数据的条数,layui会根据count，limit进行分页的计算 ,curr: currentPageAllAppoint ,skip: true ,jump: function(obj, first)&#123; currentPageAllAppoint = obj.curr; startAllAppoint = (obj.curr-1)*obj.limit; //document.getElementById('biuuu_city_list').innerHTML = render(obj, obj.curr); if(!first)&#123; //一定要加此判断，否则初始时会无限刷新 getShopCustomerManagePageInfo();//一定要把翻页的ajax请求放到这里，不然会请求两次。 //location.href = '?page='+obj.curr; &#125; &#125; &#125;); &#125;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="admin-main"&gt; &lt;blockquote class="layui-elem-quote"&gt; &lt;form class="layui-form" action="" &gt; &lt;div class="layui-form-item"&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" id="selectValue" lay-verify="required" placeholder="客户姓名，电话" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;button class="layui-btn" type="button" id="selectButton"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;span&gt;&lt;a href="shop_customer_manager_page_info"&gt;显示所有客户&lt;/a&gt;&lt;/span&gt; &lt;/blockquote&gt; &lt;fieldset class="layui-elem-field"&gt; &lt;legend&gt;客户列表&lt;/legend&gt; &lt;div class="layui-field-box layui-form"&gt; &lt;table class="layui-table admin-table" id="t_customerInfo"&gt; &lt;/table&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;div class="admin-table-page"&gt; &lt;div id="paged" class="page"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; java代码：12345678910111213141516171819202122/** * shop 客户管理 list * @param start * @param limit * @param selectValue */ @ResponseBody @RequestMapping("/list_shop_customers_info") public Object listShopCustomerInfo(Integer start, Integer limit, String selectValue) &#123; Page page = new Page(); page.setStart(start); page.setLimit(limit); // 获取session中的用户信息 User u = (User) this.request.getSession().getAttribute("userInfo"); // 获取持久化用户对象 User user = userService.findById(u.getUserId()); if (user != null) &#123; projectCustomerService.findShopCustomersByUser(user, selectValue, page); return page; &#125; &#125; sevice层12345678910111213141516171819202122232425262728@Override public void findShopCustomersByUser(User user, String selectValue, Page page) &#123; List cmList = new ArrayList&lt;&gt;(); int total = 0; if(user!=null &amp;&amp; user.getParentId()!=null &amp;&amp; !user.getParentId().equals(""))&#123; String hql = "from ShopCustomers as model where model.shopId = " + Integer.parseInt(user.getParentId()); if(selectValue!=null &amp;&amp; !selectValue.equals(""))&#123; hql+="and model.shopCustomerName like '%" +selectValue+"%' or model.shopCustomerPhone like '%" +selectValue+"%'"; &#125; List&lt;ShopCustomers&gt; list = baseDao.findByHql(hql,page.getStart(),page.getLimit()); for(ShopCustomers sc : list)&#123; User u = (User) baseDao.loadById(User.class, sc.getUserId()); String cGRSHql = "select count(*) from GuideRecords where shopCustomerId = '"+sc.getShopCustomerId()+"'"; String cDealHql = "select count(*) from GuideRecords where shopCustomerId = '"+sc.getShopCustomerId()+"' and isDeal = 1"; int floorCounts = baseDao.countQuery(cGRSHql);//备案楼盘数 int dealCounts = baseDao.countQuery(cDealHql);//已成交数 CustomerManager cm = new CustomerManager(); CustomerManager cmObj = cm.createCusManObj(sc,u); cmObj.setRecords(floorCounts); cmObj.setAlreadyDeal(dealCounts); cmList.add(cmObj); &#125; String cHql = "select count(*) "+hql; total = baseDao.countQuery(cHql); &#125; page.setRoot(cmList); page.setTotal(total); &#125; 分页对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.sc.tradmaster.utils;import java.util.List;/** * 分页对象 * @author grl 2017-01-05 * */public class Page &#123; /** 总记录数 */ private int total; /** 分页结果 */ private List root; /** 开始页码 */ private int start; /** 每页多少 */ private int limit; /** 查询条件 */ private String wheres; private int currentPage; //当前页 private int currentResult; //当前记录起始索引 private int totalPage; //总页数 public int getCurrentPage() &#123; if(currentPage&lt;=0) currentPage = 1; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getCurrentResult() &#123; currentResult = (getCurrentPage()-1)*getLimit(); if(currentResult&lt;0) currentResult = 0; return currentResult; &#125; public void setCurrentResult(int currentResult) &#123; this.currentResult = currentResult; &#125; public int getTotalPage() &#123; if(total%limit==0) totalPage = total/limit; else totalPage = total/limit+1; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public List getRoot() &#123; return root; &#125; public void setRoot(List root) &#123; this.root = root; &#125; public int getStart() &#123; return start; &#125; public void setStart(int start) &#123; this.start = start; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; this.limit = limit; &#125; public String getWheres() &#123; return wheres; &#125; public void setWheres(String wheres) &#123; this.wheres = wheres; &#125; @Override public String toString() &#123; return start+" "+total +" " +root; &#125;&#125; 如果遇到问题请联系我]]></content>
      <categories>
        <category>layui</category>
      </categories>
      <tags>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[layui完美分页，ajax请求分页（真分页）]]></title>
    <url>%2F2017%2F10%2F25%2Flayui-page-1.0%2F</url>
    <content type="text"><![CDATA[注意使用的layui版本为：layui-v1.0.9，现在新版本已经2.X了有些属性改变了，如果你的版本是2.0以上请参照我的博客：《 layui完美分页，ajax请求分页（真分页） 【2.0版本】》 这几天在工作当中需要使用分页控件，然后研究了一下layui的分页控件，这个控件页面非常简洁，功能齐全，而且可以通过异步进行数据的分页，如果大家遇到什么问题可以联系我 email：1085143002@qq.com 完整代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"&gt; &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt; &lt;meta name="apple-mobile-web-app-capable" content="yes"&gt; &lt;meta name="format-detection" content="telephone=no"&gt; &lt;link rel="icon" href="static/images/titleLogo.png" /&gt; &lt;title&gt;门店管理后台&lt;/title&gt; &lt;link rel="stylesheet" href="static/layui/plugins/layui/css/layui.css" media="all" /&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="static/css/reset.css"&gt; &lt;link rel="stylesheet" type="text/css" href="static/css/commend.css"&gt; --&gt; &lt;!-- &lt;link rel="stylesheet" href="static/css/jqpagination.css" /&gt; --&gt; &lt;!-- &lt;link rel="stylesheet" type="text/css" href="static/css/shopCustomerManager.css"&gt; --&gt; &lt;script type="text/javascript" src="static/js/jquery-3.1.1.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="static/layui/plugins/layui/layui.js"&gt;&lt;/script&gt; &lt;!-- &lt;script type="text/javascript" src="static/js/jquery.jqpagination.js"&gt;&lt;/script&gt; --&gt; &lt;script type="text/javascript"&gt; $(document).ready(function()&#123; //ajax请求后台数据 getShopCustomerManagePageInfo(); //点击搜索时 搜索数据 $("#selectButton").click(function()&#123; getShopCustomerManagePageInfo(); currentPageAllAppoint = 1; //当点击搜索的时候，应该回到第一页 toPage();//然后进行分页的初始化 &#125;) toPage(); &#125;); //分页参数设置 这些全局变量关系到分页的功能 var startAllAppoint = 0; var limitAllAppoint = 10; var currentPageAllAppoint = 1; var totalPageAllAppoint = 0; var dataLength = 0; //ajax请求后台数据 function getShopCustomerManagePageInfo()&#123; $.ajax(&#123; type:"post", async:false, url:"list_shop_customers_info", data:&#123;start:startAllAppoint, limit:limitAllAppoint,selectValue:$("#selectValue").val()&#125;, success:function(data,status)&#123; data=eval("("+data+")"); getShopCustomesInfo(data.root); startAllAppoint = data.currentResult;//当前页数(后台返回) totalPageAllAppoint = data.totalPage;//总页数(后台返回) &#125; &#125;); &#125; function getShopCustomesInfo(data)&#123; var s = "&lt;tr&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;电话&lt;/th&gt;&lt;th&gt;备案楼盘&lt;/th&gt;&lt;th&gt;已成交&lt;/th&gt;&lt;th&gt;归属经纪人&lt;/th&gt;&lt;th&gt;添加时间&lt;/th&gt;&lt;/tr&gt;"; $.each(data,function(v,o)&#123; s+='&lt;tr&gt;&lt;td&gt;'+o.cusName+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.cusSex+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.phone+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.records+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.alreadyDeal+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.theMedi+'&lt;/td&gt;'; s+='&lt;td&gt;'+o.addTime+'&lt;/td&gt;&lt;/tr&gt;'; &#125;); if(data.length&gt;0)&#123; $("#t_customerInfo").html(s); &#125;else&#123; $("#page1").hide(); $("#t_customerInfo").html("&lt;br/&gt;&lt;span style='width:10%;height:30px;display:block;margin:0 auto;'&gt;暂无数据&lt;/span&gt;"); &#125; &#125; function toPage()&#123; layui.use(['form', 'laypage', 'layedit','layer', 'laydate'], function() &#123; var form = layui.form(), layer = layui.layer, layedit = layui.layedit, laydate = layui.laydate, laypage = layui.laypage; var nums = 10; //调用分页 laypage(&#123; cont: 'paged' ,pages: totalPageAllAppoint //得到总页数，在layui2.X中使用count替代了，并且不是使用"总页数"，而是"总记录条数" ,curr: currentPageAllAppoint ,skip: true ,jump: function(obj, first)&#123; currentPageAllAppoint = obj.curr; startAllAppoint = (obj.curr-1)*limitAllAppoint; //document.getElementById('biuuu_city_list').innerHTML = render(obj, obj.curr); if(!first)&#123; //一定要加此判断，否则初始时会无限刷新 getShopCustomerManagePageInfo();//一定要把翻页的ajax请求放到这里，不然会请求两次。 //location.href = '?page='+obj.curr; &#125; &#125; &#125;); &#125;); &#125;; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="admin-main"&gt; &lt;blockquote class="layui-elem-quote"&gt; &lt;form class="layui-form" action="" &gt; &lt;div class="layui-form-item"&gt; &lt;div class="layui-input-inline"&gt; &lt;input type="text" id="selectValue" lay-verify="required" placeholder="客户姓名，电话" autocomplete="off" class="layui-input"&gt; &lt;/div&gt; &lt;button class="layui-btn" type="button" id="selectButton"&gt;搜索&lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;span&gt;&lt;a href="shop_customer_manager_page_info"&gt;显示所有客户&lt;/a&gt;&lt;/span&gt; &lt;/blockquote&gt; &lt;fieldset class="layui-elem-field"&gt; &lt;legend&gt;客户列表&lt;/legend&gt; &lt;div class="layui-field-box layui-form"&gt; &lt;table class="layui-table admin-table" id="t_customerInfo"&gt; &lt;/table&gt; &lt;/div&gt; &lt;/fieldset&gt; &lt;div class="admin-table-page"&gt; &lt;div id="paged" class="page"&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; java代码：123456789101112131415161718192021/** * shop 客户管理 list * @param start * @param limit * @param selectValue */ @ResponseBody @RequestMapping("/list_shop_customers_info") public Object listShopCustomerInfo(Integer start, Integer limit, String selectValue) &#123; Page page = new Page(); page.setStart(start); page.setLimit(limit); // 获取session中的用户信息 User u = (User) this.request.getSession().getAttribute("userInfo"); // 获取持久化用户对象 User user = userService.findById(u.getUserId()); if (user != null) &#123; projectCustomerService.findShopCustomersByUser(user, selectValue, page); return page; &#125; &#125; sevice层12345678910111213141516171819202122232425262728@Override public void findShopCustomersByUser(User user, String selectValue, Page page) &#123; List cmList = new ArrayList&lt;&gt;(); int total = 0; if(user!=null &amp;&amp; user.getParentId()!=null &amp;&amp; !user.getParentId().equals(""))&#123; String hql = "from ShopCustomers as model where model.shopId = " + Integer.parseInt(user.getParentId()); if(selectValue!=null &amp;&amp; !selectValue.equals(""))&#123; hql+="and model.shopCustomerName like '%" +selectValue+"%' or model.shopCustomerPhone like '%" +selectValue+"%'"; &#125; List&lt;ShopCustomers&gt; list = baseDao.findByHql(hql,page.getStart(),page.getLimit()); for(ShopCustomers sc : list)&#123; User u = (User) baseDao.loadById(User.class, sc.getUserId()); String cGRSHql = "select count(*) from GuideRecords where shopCustomerId = '"+sc.getShopCustomerId()+"'"; String cDealHql = "select count(*) from GuideRecords where shopCustomerId = '"+sc.getShopCustomerId()+"' and isDeal = 1"; int floorCounts = baseDao.countQuery(cGRSHql);//备案楼盘数 int dealCounts = baseDao.countQuery(cDealHql);//已成交数 CustomerManager cm = new CustomerManager(); CustomerManager cmObj = cm.createCusManObj(sc,u); cmObj.setRecords(floorCounts); cmObj.setAlreadyDeal(dealCounts); cmList.add(cmObj); &#125; String cHql = "select count(*) "+hql; total = baseDao.countQuery(cHql); &#125; page.setRoot(cmList); page.setTotal(total); &#125; 分页对象123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.sc.tradmaster.utils;import java.util.List;/** * 分页对象 * @author grl 2017-01-05 * */public class Page &#123; /** 总记录数 */ private int total; /** 分页结果 */ private List root; /** 开始页码 */ private int start; /** 每页多少 */ private int limit; /** 查询条件 */ private String wheres; private int currentPage; //当前页 private int currentResult; //当前记录起始索引 private int totalPage; //总页数 public int getCurrentPage() &#123; if(currentPage&lt;=0) currentPage = 1; return currentPage; &#125; public void setCurrentPage(int currentPage) &#123; this.currentPage = currentPage; &#125; public int getCurrentResult() &#123; currentResult = (getCurrentPage()-1)*getLimit(); if(currentResult&lt;0) currentResult = 0; return currentResult; &#125; public void setCurrentResult(int currentResult) &#123; this.currentResult = currentResult; &#125; public int getTotalPage() &#123; if(total%limit==0) totalPage = total/limit; else totalPage = total/limit+1; return totalPage; &#125; public void setTotalPage(int totalPage) &#123; this.totalPage = totalPage; &#125; public int getTotal() &#123; return total; &#125; public void setTotal(int total) &#123; this.total = total; &#125; public List getRoot() &#123; return root; &#125; public void setRoot(List root) &#123; this.root = root; &#125; public int getStart() &#123; return start; &#125; public void setStart(int start) &#123; this.start = start; &#125; public int getLimit() &#123; return limit; &#125; public void setLimit(int limit) &#123; this.limit = limit; &#125; public String getWheres() &#123; return wheres; &#125; public void setWheres(String wheres) &#123; this.wheres = wheres; &#125; @Override public String toString() &#123; return start+" "+total +" " +root; &#125;&#125;]]></content>
      <categories>
        <category>layui</category>
      </categories>
      <tags>
        <tag>layui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot中使用Swagger2构建强大的RESTful API文档]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-boot-swagger2%2F</url>
    <content type="text"><![CDATA[由于Spring Boot能够快速开发、便捷部署等特性，相信有很大一部分Spring Boot的用户会用来构建RESTful API。而我们构建RESTful API的目的通常都是由于多终端的原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。这样一来，我们的RESTful API就有可能要面对多个开发人员或多个开发团队：IOS开发、Android开发或是Web开发等。为了减少与其他团队平时开发期间的频繁沟通成本，传统做法我们会创建一份RESTful API文档来记录所有接口细节，然而这样的做法有以下几个问题： 由于接口众多，并且细节复杂（需要考虑不同的HTTP请求类型、HTTP头部信息、HTTP请求内容等），高质量地创建这份文档本身就是件非常吃力的事，下游的抱怨声不绝于耳。 随着时间推移，不断修改接口实现的时候都必须同步修改接口文档，而文档与代码又处于两个不同的媒介，除非有严格的管理机制，不然很容易导致不一致现象。 为了解决上面这样的问题，本文将介绍RESTful API的重磅好伙伴Swagger2，它可以轻松的整合到Spring Boot中，并与Spring MVC程序配合组织出强大RESTful API文档。它既可以减少我们创建文档的工作量，同时说明内容又整合入实现代码中，让维护文档和修改代码整合为一体，可以让我们在修改代码逻辑的同时方便的修改文档说明。另外Swagger2也提供了强大的页面测试功能来调试每个RESTful API。具体效果如下图所示： 下面来具体介绍，如果在Spring Boot中使用Swagger2。首先，我们需要一个Spring Boot实现的RESTful API工程，若您没有做过这类内容，建议先阅读Spring Boot构建一个较为复杂的RESTful APIs和单元测试。 下面的内容我们会以教程样例中的Chapter3-1-1进行下面的实验（Chpater3-1-5是我们的结果工程，亦可参考）。 添加Swagger2依赖在pom.xml中加入Swagger2的依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 创建Swagger2配置类在Application.java同级创建Swagger2的配置类Swagger2。 12345678910111213141516171819202122@Configuration@EnableSwagger2public class Swagger2 &#123; @Bean public Docket createRestApi() &#123; return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select() .apis(RequestHandlerSelectors.basePackage("com.didispace.web")) .paths(PathSelectors.any()) .build(); &#125; private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("Spring Boot中使用Swagger2构建RESTful APIs") .description("更多Spring Boot相关文章请关注：http://blog.didispace.com/") .termsOfServiceUrl("http://blog.didispace.com/") .contact("程序猿DD") .version("1.0") .build(); &#125;&#125; 如上代码所示，通过@Configuration注解，让Spring来加载该类配置。再通过@EnableSwagger2注解来启用Swagger2。 再通过createRestApi函数创建Docket的Bean之后，apiInfo()用来创建该Api的基本信息（这些基本信息会展现在文档页面中）。select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现，本例采用指定扫描的包路径来定义，Swagger会扫描该包下所有Controller定义的API，并产生文档内容（除了被@ApiIgnore指定的请求）。 添加文档内容在完成了上述配置后，其实已经可以生产文档内容，但是这样的文档主要针对请求本身，而描述主要来源于函数等命名产生，对用户并不友好，我们通常需要自己增加一些说明来丰富文档内容。如下所示，我们通过@ApiOperation注解来给API增加说明、通过@ApiImplicitParams、@ApiImplicitParam注解来给参数增加说明。 1234567891011121314151617181920212223242526272829303132333435363738394041424344@RestController@RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下，可去除public class UserController &#123; static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @ApiOperation(value="获取用户列表", notes="") @RequestMapping(value=&#123;""&#125;, method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @ApiOperation(value="创建用户", notes="根据User对象创建用户") @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") @RequestMapping(value="", method=RequestMethod.POST) public String postUser(@RequestBody User user) &#123; users.put(user.getId(), user); return "success"; &#125; @ApiOperation(value="获取用户详细信息", notes="根据url的id来获取用户详细信息") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; return users.get(id); &#125; @ApiOperation(value="更新用户详细信息", notes="根据url的id来指定更新对象，并根据传过来的user信息来更新用户详细信息") @ApiImplicitParams(&#123; @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long"), @ApiImplicitParam(name = "user", value = "用户详细实体user", required = true, dataType = "User") &#125;) @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @RequestBody User user) &#123; User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @ApiOperation(value="删除用户", notes="根据url的id来指定删除对象") @ApiImplicitParam(name = "id", value = "用户ID", required = true, dataType = "Long") @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; users.remove(id); return "success"; &#125;&#125; 完成上述代码添加上，启动Spring Boot程序，访问：http://localhost:8080/swagger-ui.html。就能看到前文所展示的RESTful API的页面。我们可以再点开具体的API请求，以POST类型的/users请求为例，可找到上述代码中我们配置的Notes信息以及参数user的描述信息，如下图所示。 API文档访问与调试在上图请求的页面中，我们看到user的Value是个输入框？是的，Swagger除了查看接口功能外，还提供了调试测试功能，我们可以点击上图中右侧的Model Schema（黄色区域：它指明了User的数据结构），此时Value中就有了user对象的模板，我们只需要稍适修改，点击下方“Try it out！”按钮，即可完成了一次请求调用！ 此时，你也可以通过几个GET请求来验证之前的POST请求是否正确。 相比为这些接口编写文档的工作，我们增加的配置内容是非常少而且精简的，对于原有代码的侵入也在忍受范围之内。因此，在构建RESTful API的同时，加入swagger来对API文档进行管理，是个不错的选择。 完整结果示例可查看Chapter3-1-5。 参考信息 Swagger官方网站 原作者：程序员didi原文出处：http://blog.didispace.com/springbootswagger2/]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot工程结构推荐]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-boot-project%2F</url>
    <content type="text"><![CDATA[今天看了一位简书上朋友发来的工程，于是想到应该要写这么一篇。前人总结的最佳实践案例可以帮助我们免去很多不必要的麻烦。花点时间来看一下本文，绝对物超所值。 工程结构（最佳实践） Spring Boot框架本身并没有对工程结构有特别的要求，但是按照最佳实践的工程结构可以帮助我们减少可能会遇见的坑，尤其是Spring包扫描机制的存在，如果您使用最佳实践的工程结构，可以免去不少特殊的配置工作。 典型示例 root package结构：com.example.myproject 应用主类Application.java置于root package下，通常我们会在应用主类中做一些框架配置扫描等配置， 我们放在root package下可以帮助程序减少手工配置来加载到我们希望被Spring加载的内容 实体（Entity）与数据访问层（Repository）置于com.example.myproject.domain包下 逻辑层（Service）置于com.example.myproject.service包下 Web层（web）置于com.example.myproject.web包下 123456789101112131415com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web | +- CustomerController.java | 看看您现在的功能是否这样配置，如果不是，不妨尝试改变一下，看看是否可以去掉一些@Configuration配置？ 原作者：程序员didi原文出处：http://blog.didispace.com/springbootproject/]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot构建RESTful API与单元测试]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-boot-restful-api%2F</url>
    <content type="text"><![CDATA[首先，回顾并详细说明一下在快速入门中使用的@Controller、@RestController、@RequestMapping注解。如果您对Spring MVC不熟悉并且还没有尝试过快速入门案例，建议先看一下快速入门的内容。 @Controller：修饰class，用来创建处理http请求的对象 @RestController：Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 @RequestMapping：配置url映射 下面我们尝试使用Spring MVC来实现一组对User对象操作的RESTful API，配合注释详细说明在Spring MVC中如何映射HTTP请求、如何传参、如何编写单元测试。 RESTful API具体设计如下： User实体定义： 123456789public class User &#123; private Long id; private String name; private Integer age; // 省略setter和getter &#125; 实现对User对象的操作接口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RestController @RequestMapping(value="/users") // 通过这里配置使下面的映射都在/users下 public class UserController &#123; // 创建线程安全的Map static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @RequestMapping(value="/", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; // 处理"/users/"的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @RequestMapping(value="/", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理"/users/"的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return "success"; &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; // 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return "success"; &#125; @RequestMapping(value="/&#123;id&#125;", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; // 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User users.remove(id); return "success"; &#125; &#125; 下面针对该Controller编写测试用例验证正确性，具体如下。当然也可以通过浏览器插件等进行请求提交验证。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@RunWith(SpringJUnit4ClassRunner.class) @SpringApplicationConfiguration(classes = MockServletContext.class) @WebAppConfiguration public class ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new UserController()).build(); &#125; @Test public void testUserController() throws Exception &#123; // 测试UserController RequestBuilder request = null; // 1、get查一下user列表，应该为空 request = get("/users/"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo("[]"))); // 2、post提交一个user request = post("/users/") .param("id", "1") .param("name", "测试大师") .param("age", "20"); mvc.perform(request) .andExpect(content().string(equalTo("success"))); // 3、get获取user列表，应该有刚才插入的数据 request = get("/users/"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo("[&#123;\"id\":1,\"name\":\"测试大师\",\"age\":20&#125;]"))); // 4、put修改id为1的user request = put("/users/1") .param("name", "测试终极大师") .param("age", "30"); mvc.perform(request) .andExpect(content().string(equalTo("success"))); // 5、get一个id为1的user request = get("/users/1"); mvc.perform(request) .andExpect(content().string(equalTo("&#123;\"id\":1,\"name\":\"测试终极大师\",\"age\":30&#125;"))); // 6、del删除id为1的user request = delete("/users/1"); mvc.perform(request) .andExpect(content().string(equalTo("success"))); // 7、get查一下user列表，应该为空 request = get("/users/"); mvc.perform(request) .andExpect(status().isOk()) .andExpect(content().string(equalTo("[]"))); &#125; &#125; 至此，我们通过引入web模块（没有做其他的任何配置），就可以轻松利用Spring MVC的功能，以非常简洁的代码完成了对User对象的RESTful API的创建以及单元测试的编写。其中同时介绍了Spring MVC中最为常用的几个核心注解：@Controller,@RestController,RequestMapping以及一些参数绑定的注解：@PathVariable,@ModelAttribute,@RequestParam等。 代码示例springboot完整案例 原作者：程序员didi原文出处：http://blog.didispace.com/springbootrestfulapi/]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot开发Web应用]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-boot-web%2F</url>
    <content type="text"><![CDATA[Spring Boot快速入门中我们完成了一个简单的RESTful Service，体验了快速开发的特性。在留言中也有朋友提到如何把处理结果渲染到页面上。那么本篇就在上篇基础上介绍一下如何进行Web应用的开发。 静态资源访问在我们开发Web应用的时候，需要引用大量的js、css、图片等静态资源。 默认配置Spring Boot默认提供静态资源目录位置需置于classpath下，目录名需符合如下规则： /static /public /resources /META-INF/resources 举例：我们可以在123456789101112131415161718192021222324252627282930313233343536373839404142434445### 渲染Web页面在之前的示例中，我们都是通过@RestController来处理请求，所以返回的内容为json对象。那么如果需要渲染html页面的时候，要如何实现呢？### 模板引擎在动态HTML实现上Spring Boot依然可以完美胜任，并且提供了多种模板引擎的默认配置支持，所以在推荐的模板引擎下，我们可以很快的上手开发动态网站。Spring Boot提供了默认配置的模板引擎主要有以下几种：* Thymeleaf* FreeMarker* Velocity* Groovy* Mustache**Spring Boot建议使用这些模板引擎，避免使用JSP，若一定要使用JSP将无法实现Spring Boot的多种特性，具体可见后文：支持JSP的配置**当你使用上述模板引擎中的任何一个，它们默认的模板配置路径为：`src/main/resources/templates`。当然也可以修改这个路径，具体如何修改，可在后续各模板引擎的配置属性中查询并修改。### Thymeleafhymeleaf是一个XML/XHTML/HTML5模板引擎，可用于Web与非Web环境中的应用开发。它是一个开源的Java库，基于Apache License 2.0许可，由Daniel Fernández创建，该作者还是Java加密库Jasypt的作者。Thymeleaf提供了一个用于整合Spring MVC的可选模块，在应用开发中，你可以使用Thymeleaf来完全代替JSP或其他模板引擎，如Velocity、FreeMarker等。Thymeleaf的主要目标在于提供一种可被浏览器正确显示的、格式良好的模板创建方式，因此也可以用作静态建模。你可以使用它创建经过验证的XML与HTML模板。相对于编写逻辑或代码，开发者只需将标签属性添加到模板中即可。接下来，这些标签属性就会在DOM（文档对象模型）上执行预先制定好的逻辑。示例模板：```html&lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th th:text=&quot;#&#123;msgs.headers.name&#125;&quot;&gt;Name&lt;/td&gt; &lt;th th:text=&quot;#&#123;msgs.headers.price&#125;&quot;&gt;Price&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;prod : $&#123;allProducts&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;prod.name&#125;&quot;&gt;Oranges&lt;/td&gt; &lt;td th:text=&quot;$&#123;#numbers.formatDecimal(prod.price,1,2)&#125;&quot;&gt;0.99&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; 可以看到Thymeleaf主要以属性的方式加入到html标签中，浏览器在解析html时，当检查到没有的属性时候会忽略，所以Thymeleaf的模板可以通过浏览器直接打开展现，这样非常有利于前后端的分离。 在Spring Boot中使用Thymeleaf，只需要引入下面依赖，并在默认的模板路径123456```xml&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 在完成配置之后，举一个简单的例子，在快速入门工程的基础上，举一个简单的示例来通过Thymeleaf渲染一个页面。 12345678910@Controllerpublic class HelloController &#123; @RequestMapping("/") public String index(ModelMap map) &#123; // 加入一个属性，用来在模板中读取 map.addAttribute("host", "http://blog.didispace.com"); // return模板文件的名称，对应src/main/resources/templates/index.html return "index"; &#125;&#125; 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8" /&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1 th:text="$&#123;host&#125;"&gt;Hello World&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 如上页面，直接打开html页面展现Hello World，但是启动程序后，访问http://localhost:8080/，则是展示Controller中host的值：http://blog.didispace.com，做到了不破坏HTML自身内容的数据逻辑分离。 更多Thymeleaf的页面语法，还请访问Thymeleaf的官方文档查询使用。 Thymeleaf的默认参数配置如有需要修改默认配置的时候，只需复制下面要修改的属性到application.properties中，并修改成需要的值，如修改模板文件的扩展名，修改默认的模板路径等。 123456789101112131415161718# Enable template caching.spring.thymeleaf.cache=true # Check that the templates location exists.spring.thymeleaf.check-template-location=true # Content-Type value.spring.thymeleaf.content-type=text/html # Enable MVC Thymeleaf view resolution.spring.thymeleaf.enabled=true # Template encoding.spring.thymeleaf.encoding=UTF-8 # Comma-separated list of view names that should be excluded from resolution.spring.thymeleaf.excluded-view-names= # Template mode to be applied to templates. See also StandardTemplateModeHandlers.spring.thymeleaf.mode=HTML5 # Prefix that gets prepended to view names when building a URL.spring.thymeleaf.prefix=classpath:/templates/ # Suffix that gets appended to view names when building a URL.spring.thymeleaf.suffix=.html spring.thymeleaf.template-resolver-order= # Order of the template resolver in the chain. spring.thymeleaf.view-names= # Comma-separated list of view names that can be resolved. 支持JSP的配置Spring Boot并不建议使用，但如果一定要使用，可以参考此工程作为脚手架：JSP支持 spring boot完整案例 原作者：程序员didi原文出处：http://blog.didispace.com/springbootweb/]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot快速入门]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-boot-learning-1%2F</url>
    <content type="text"><![CDATA[简介在您第1次接触和学习Spring框架的时候，是否因为其繁杂的配置而退却了？在你第n次使用Spring框架的时候，是否觉得一堆反复黏贴的配置有一些厌烦？那么您就不妨来试试使用Spring Boot来让你更易上手，更简单快捷地构建Spring应用！Spring Boot让我们的Spring应用变的更轻量化。比如：你可以仅仅依靠一个Java类来运行一个Spring引用。你也可以打包你的应用为jar并通过使用java -jar来运行你的Spring Web应用。 Spring Boot的主要优点： 为所有Spring开发者更快的入门 开箱即用，提供各种默认配置来简化项目配置 内嵌式容器简化Web项目 没有冗余代码生成和XML配置的要求 快速入门本章主要目标完成Spring Boot基础项目的构建，并且实现一个简单的Http请求处理，通过这个例子对Spring Boot有一个初步的了解，并体验其结构简单、开发快速的特性。 系统要求： Java 7及以上 Spring Framework 4.1.5及以上 **本文采用1.8.0_73```、```Spring Boot 1.3.2```调试通过。**12345678910111213141516171819202122232425### 使用Maven构建项目1. 通过SPRING INITIALIZR工具产生基础项目 1. 访问：http://start.spring.io/ 2. 选择构建工具Maven Project、Spring Boot版本1.3.2以及一些工程基本信息，可参考下图所示 ![](http://blog.didispace.com/content/images/2016/02/chapter1-1.png) 3. 点击Generate Project下载项目压缩包2. 解压项目包，并用IDE以Maven项目导入，以IntelliJ IDEA 14为例： 1. 菜单中选择File–&gt;New–&gt;Project from Existing Sources... 2. 选择解压后的项目文件夹，点击OK 3. 点击Import project from external model并选择Maven，点击Next到底为止。 4. 若你的环境有多个版本的JDK，注意到选择Java SDK的时候请选择Java 7以上的版本### 项目结构解析![项目结构](http://blog.didispace.com/content/images/2016/02/chapter1-2.png)通过上面步骤完成了基础项目的创建，如上图所示，Spring Boot的基础结构共三个文件（具体路径根据用户生成项目时填写的Group所有差异）：* ```src/main/java```下的程序入口：```Chapter1Application 1* ```src/test/```下的测试入口：```Chapter1ApplicationTests 生成的1234567891011121314151617181920### 引入Web模块当前的```pom.xml```内容如下，仅引入了两个模块：* spring-boot-starter：核心模块，包括自动配置支持、日志和YAML* spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito```xml&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 引入Web模块，需添加spring-boot-starter-web模块： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 编写HelloWorld服务 创建package命名为com.didispace.web（根据实际情况修改） 创建HelloController类，内容如下 1234567@RestControllerpublic class HelloController &#123; @RequestMapping("/hello") public String index() &#123; return "Hello World"; &#125;&#125; 启动主程序，打开浏览器访问http://localhost:8080/hello，可以看到页面输出World```12345678910111213141516171819202122### 编写单元测试用例打开的```src/test/```下的测试入口```Chapter1ApplicationTests```类。下面编写一个简单的单元测试来模拟http请求，具体如下：```java@RunWith(SpringJUnit4ClassRunner.class)@SpringApplicationConfiguration(classes = MockServletContext.class)@WebAppConfigurationpublic class Chapter1ApplicationTests &#123; private MockMvc mvc; @Before public void setUp() throws Exception &#123; mvc = MockMvcBuilders.standaloneSetup(new HelloController()).build(); &#125; @Test public void getHello() throws Exception &#123; mvc.perform(MockMvcRequestBuilders.get(&quot;/hello&quot;).accept(MediaType.APPLICATION_JSON)) .andExpect(status().isOk()) .andExpect(content().string(equalTo(&quot;Hello World&quot;))); &#125;&#125; 使用1234567* 注意引入下面内容，让```status```、```content```、```equalTo```函数可用```javaimport static org.hamcrest.Matchers.equalTo;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status; 至此已完成目标，通过Maven构建了一个空白Spring Boot项目，再通过引入web模块实现了一个简单的请求处理。 原作者：程序员didi原文出处：http://blog.didispace.com/spring-boot-learning-1/]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务网关（过滤器）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-cloud-starter-dalston-6-3%2F</url>
    <content type="text"><![CDATA[在前两篇文章：服务网关（基础）、服务网关（路由配置）中，我们了解了Spring Cloud Zuul作为网关所具备的最基本功能：路由。本文我们将具体介绍一下Spring Cloud Zuul的另一项核心功能：过滤器。 过滤器的作用 通过上面所述的两篇我们，我们已经能够实现请求的路由功能，所以我们的微服务应用提供的接口就可以通过统一的API网关入口被客户端访问到了。但是，每个客户端用户请求微服务应用提供的接口时，它们的访问权限往往都需要有一定的限制，系统并不会将所有的微服务接口都对它们开放。然而，目前的服务路由并没有限制权限这样的功能，所有请求都会被毫无保留地转发到具体的应用并返回结果，为了实现对客户端请求的安全校验和权限控制，最简单和粗暴的方法就是为每个微服务应用都实现一套用于校验签名和鉴别权限的过滤器或拦截器。不过，这样的做法并不可取，它会增加日后的系统维护难度，因为同一个系统中的各种校验逻辑很多情况下都是大致相同或类似的，这样的实现方式会使得相似的校验逻辑代码被分散到了各个微服务中去，冗余代码的出现是我们不希望看到的。所以，比较好的做法是将这些校验逻辑剥离出去，构建出一个独立的鉴权服务。在完成了剥离之后，有不少开发者会直接在微服务应用中通过调用鉴权服务来实现校验，但是这样的做法仅仅只是解决了鉴权逻辑的分离，并没有在本质上将这部分不属于业余的逻辑拆分出原有的微服务应用，冗余的拦截器或过滤器依然会存在。 对于这样的问题，更好的做法是通过前置的网关服务来完成这些非业务性质的校验。由于网关服务的加入，外部客户端访问我们的系统已经有了统一入口，既然这些校验与具体业务无关，那何不在请求到达的时候就完成校验和过滤，而不是转发后再过滤而导致更长的请求延迟。同时，通过在网关中完成校验和过滤，微服务应用端就可以去除各种复杂的过滤器和拦截器了，这使得微服务应用的接口开发和测试复杂度也得到了相应的降低。 为了在API网关中实现对客户端请求的校验，我们将需要使用到Spring Cloud Zuul的另外一个核心功能：过滤器。 Zuul允许开发者在API网关上通过定义过滤器来实现对请求的拦截与过滤，实现的方法非常简单，我们只需要继承ZuulFilter抽象类并实现它定义的四个抽象函数就可以完成对请求的拦截和过滤了。 过滤器的实现比如下面的代码，我们定义了一个简单的Zuul过滤器，它实现了在请求被路由之前检查HttpServletRequest中是否有accessToken参数，若有就进行路由，若没有就拒绝访问，返回401 Unauthorized错误。 123456789101112131415161718192021222324252627282930public class AccessFilter extends ZuulFilter &#123; private static Logger log = LoggerFactory.getLogger(AccessFilter.class); @Override public String filterType() &#123; return "pre"; &#125; @Override public int filterOrder() &#123; return 0; &#125; @Override public boolean shouldFilter() &#123; return true; &#125; @Override public Object run() &#123; RequestContext ctx = RequestContext.getCurrentContext(); HttpServletRequest request = ctx.getRequest(); log.info("send &#123;&#125; request to &#123;&#125;", request.getMethod(), request.getRequestURL().toString()); Object accessToken = request.getParameter("accessToken"); if(accessToken == null) &#123; log.warn("access token is empty"); ctx.setSendZuulResponse(false); ctx.setResponseStatusCode(401); return null; &#125; log.info("access token ok"); return null; &#125;&#125; 在上面实现的过滤器代码中，我们通过继承1234567891011121314151617181920* ```filterType```：过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。这里定义为```pre```，代表会在请求被路由之前执行。* ```filterOrder```：过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，需要根据该方法返回的值来依次执行。* ```shouldFilter```：判断该过滤器是否需要被执行。这里我们直接返回了```true```，因此该过滤器对所有请求都会生效。实际运用中我们可以利用该函数来指定过滤器的有效范围。* ```run```：过滤器的具体逻辑。这里我们通过```ctx.setSendZuulResponse(false)```令```zuul```过滤该请求，不对其进行路由，然后通过```ctx.setResponseStatusCode(401)```设置了其返回的错误码，当然我们也可以进一步优化我们的返回，比如，通过```ctx.setResponseBody(body)```对返回```body```内容进行编辑等。在实现了自定义过滤器之后，它并不会直接生效，我们还需要为其创建具体的Bean才能启动该过滤器，比如，在应用主类中增加如下内容：```java@EnableZuulProxy@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125; @Bean public AccessFilter accessFilter() &#123; return new AccessFilter(); &#125;&#125; 在对123* http://localhost:1101/api-a/hello：返回401错误* http://localhost:1101/api-a/hello&amp;accessToken=token：正确路由到```hello-service```的```/hello```接口，并返回```Hello World 到这里，对于Spring Cloud Zuul过滤器的基本功能就以介绍完毕。读者可以根据自己的需要在服务网关上定义一些与业务无关的通用逻辑实现对请求的过滤和拦截，比如：签名校验、权限校验、请求限流等功能。 进阶阅读为了更好的理解和扩展Spring Cloud Zuul，我们可以阅读下面这些文章，有助于深入的了解其内部运行机制，以指导我们合理的编写过滤器逻辑： Spring Cloud源码分析（四）Zuul：核心过滤器 Spring Cloud实战小贴士：Zuul处理Cookie和重定向 Spring Cloud实战小贴士：Zuul统一异常处理（一） Spring Cloud实战小贴士：Zuul统一异常处理（二） Spring Cloud实战小贴士：Zuul统一异常处理（三）【Dalston版】 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-6-3/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务网关（路由配置）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-cloud-starter-dalston-6-2%2F</url>
    <content type="text"><![CDATA[在上一篇《Spring Cloud构建微服务架构：服务网关（基础）》一文中，我们通过使用Spring Cloud Zuul构建了一个基础的API网关服务，同时也演示了Spring Cloud Zuul基于服务的自动路由功能。在本文中，我们将进一步详细地介绍关于Spring Cloud Zuul的路由功能，以帮助读者可以更好的理解和使用它，以完成更复杂的路由配置。 传统路由配置 所谓的传统路由配置方式就是在不依赖于服务发现机制的情况下，通过在配置文件中具体指定每个路由表达式与服务实例的映射关系来实现API网关对外部请求的路由。 没有Eureka和Consul的服务治理框架帮助的时候，我们需要根据服务实例的数量采用不同方式的配置来实现路由规则： 单实例配置：通过一组1234```propertieszuul.routes.user-service.path=/user-service/**zuul.routes.user-service.url=http://localhost:8080/ 该配置实现了对符合123456789* 多实例配置：通过一组zuul.routes.&lt;route&gt;.path与zuul.routes.&lt;route&gt;.serviceId参数对的方式配置，比如：```propertieszuul.routes.user-service.path=/user-service/**zuul.routes.user-service.serviceId=user-serviceribbon.eureka.enabled=falseuser-service.ribbon.listOfServers=http://localhost:8080/,http://localhost:8081/ 该配置实现了对符合Cloud Ribbon的配合。由于在Spring Cloud Zuul中自带了对Ribbon的依赖，所以我们只需要做一些配置即可，比如上面示例中关于Ribbon的各个配置，它们的具体作用如下：123456789101112131415* ```ribbon.eureka.enabled```：由于```zuul.routes.&lt;route&gt;.serviceId```指定的是服务名称，默认情况下Ribbon会根据服务发现机制来获取配置服务名对应的实例清单。但是，该示例并没有整合类似Eureka之类的服务治理框架，所以需要将该参数设置为false，不然配置的```serviceId```是获取不到对应实例清单的。* ```user-service.ribbon.listOfServers```：该参数内容与```zuul.routes.&lt;route&gt;.serviceId```的配置相对应，开头的```user-service```对应了```serviceId```的值，这两个参数的配置相当于在该应用内部手工维护了服务与实例的对应关系。不论是单实例还是多实例的配置方式，我们都需要为每一对映射关系指定一个名称，也就是上面配置中的```&lt;route&gt;```，每一个```&lt;route&gt;```就对应了一条路由规则。每条路由规则都需要通过```path```属性来定义一个用来匹配客户端请求的路径表达式，并通过```url```或```serviceId```属性来指定请求表达式映射具体实例地址或服务名。### 服务路由配置服务路由我们在上一篇中也已经有过基础的介绍和体验，Spring Cloud Zuul通过与Spring Cloud Eureka的整合，实现了对服务实例的自动化维护，所以在使用服务路由配置的时候，我们不需要向传统路由配置方式那样为```serviceId```去指定具体的服务实例地址，只需要通过一组```zuul.routes.&lt;route&gt;.path```与```zuul.routes.&lt;route&gt;.serviceId```参数对的方式配置即可。比如下面的示例，它实现了对符合```/user-service/**```规则的请求路径转发到名为```user-service```的服务实例上去的路由规则。其中```&lt;route&gt;```可以指定为任意的路由名称。```propertieszuul.routes.user-service.path=/user-service/**zuul.routes.user-service.serviceId=user-service 对于面向服务的路由配置，除了使用1234```properties zuul.routes.user-service=/user-service/** 传统路由的映射方式比较直观且容易理解，API网关直接根据请求的URL路径找到最匹配的path表达式，直接转发给该表达式对应的url或对应serviceId下配置的实例地址，以实现外部请求的路由。那么当采用path与serviceId以服务路由方式实现时候，没有配置任何实例地址的情况下，外部请求经过API网关的时候，它是如何被解析并转发到服务具体实例的呢？ 在Spring Cloud Netflix中，Zuul巧妙的整合了Eureka来实现面向服务的路由。实际上，我们可以直接将API网关也看做是Eureka服务治理下的一个普通微服务应用。它除了会将自己注册到Eureka服务注册中心上之外，也会从注册中心获取所有服务以及它们的实例清单。所以，在Eureka的帮助下，API网关服务本身就已经维护了系统中所有serviceId与实例地址的映射关系。当有外部请求到达API网关的时候，根据请求的URL路径找到最佳匹配的path规则，API网关就可以知道要将该请求路由到哪个具体的serviceId上去。由于在API网关中已经知道serviceId对应服务实例的地址清单，那么只需要通过Ribbon的负载均衡策略，直接在这些清单中选择一个具体的实例进行转发就能完成路由工作了。 示例仓库 码云：点击查看 GitHub:点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-6-2/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务网关（基础）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-cloud-starter-dalston-6-1%2F</url>
    <content type="text"><![CDATA[通过之前几篇Spring Cloud中几个核心组件的介绍，我们已经可以构建一个简略的（不够完善）微服务架构了。比如下图所示： 我们使用Spring Cloud Netflix中的Eureka实现了服务注册中心以及服务注册与发现；而服务间通过Ribbon或Feign实现服务的消费以及均衡负载；通过Spring Cloud Config实现了应用多环境的外部化配置以及版本管理。为了使得服务集群更为健壮，使用Hystrix的融断机制来避免在微服务架构中个别服务出现异常时引起的故障蔓延。 在该架构中，我们的服务集群包含：内部服务Service A和Service B，他们都会注册与订阅服务至Eureka Server，而Open Service是一个对外的服务，通过均衡负载公开至服务调用方。本文我们把焦点聚集在对外服务这块，这样的实现是否合理，或者是否有更好的实现方式呢？ 先来说说这样架构需要做的一些事儿以及存在的不足： 首先，破坏了服务无状态特点。为了保证对外服务的安全性，我们需要实现对服务访问的权限控制，而开放服务的权限控制机制将会贯穿并污染整个开放服务的业务逻辑，这会带来的最直接问题是，破坏了服务集群中REST API无状态的特点。从具体开发和测试的角度来说，在工作中除了要考虑实际的业务逻辑之外，还需要额外可续对接口访问的控制处理。 其次，无法直接复用既有接口。当我们需要对一个即有的集群内访问接口，实现外部服务访问时，我们不得不通过在原有接口上增加校验逻辑，或增加一个代理调用来实现权限控制，无法直接复用原有的接口。 为了解决上面这些问题，我们需要将权限控制这样的东西从我们的服务单元中抽离出去，而最适合这些逻辑的地方就是处于对外访问最前端的地方，我们需要一个更强大一些的均衡负载器，它就是本文将来介绍的：服务网关。 服务网关是微服务架构中一个不可或缺的部分。通过服务网关统一向外系统提供REST API的过程中，除了具备服务路由、均衡负载功能之外，它还具备了权限控制等功能。Spring Cloud Netflix中的Zuul就担任了这样的一个角色，为微服务架构提供了前门保护的作用，同时将权限控制这些较重的非业务逻辑内容迁移到服务路由层面，使得服务集群主体能够具备更高的可复用性和可测试性。 下面我们通过实例例子来使用一下Zuul来作为服务的路有功能。 准备工作在构建服务网关之前，我们先准备一下网关内部的微服务，可以直接使用前几篇编写的内容，比如： eureka-client eureka-consumer 由于我们用了基于eureka的服务，所以我们可以使用我的公益注册中心：http://eureka.didispace.com/ 这些服务可从我的仓库中直接获取： Github：https://github.com/dyc87112/SpringCloud-Learning 码云：https://gitee.com/didispace/SpringCloud-Learning 在启动了eureka-client和eureka-consumer的实例之后，所有的准备工作就以就绪，下面我们来试试使用Spring Cloud Zuul来实现服务网关的功能。 构建服务网关使用Spring Cloud Zuul来构建服务网关的基础步骤非常简单，只需要下面几步： 创建一个基础的Spring Boot项目，命名为：api-gateway。并在pom.xml中引入依赖： 123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 创建应用主类，并使用@EnableZuulProxy注解开启Zuul的功能。 123456789@EnableZuulProxy@SpringCloudApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125; &#125; 创建配置文件application.yaml，并加入服务名、端口号、eureka注册中心的地址： 123456789spring: application: name: api-gatewayserver: port: 1101eureka: client: serviceUrl: defaultZone: http://eureka.didispace.com/eureka/ 到这里，一个基于Spring Cloud Zuul服务网关就已经构建完毕。启动该应用，一个默认的服务网关就构建完毕了。由于Spring Cloud Zuul在整合了Eureka之后，具备默认的服务路由功能，即：当我们这里构建的123* 转发到```eureka-client```服务的请求规则为：```/eureka-client/** 转发到eureka-consumer服务的请求规则为：/eureka-consumer/** 最后，我们可以通过访问1101端口的服务网关来验证上述路由的正确性： 比如访问：http://localhost:1101/eureka-client/dc ，该请求将最终被路由到eureka-client的/dc接口上。 本篇小结本篇，我们介绍了构建服务网关的基础。通过上面的构建内容，我们已经为所有内部服务提供了一个统一的对外入口，同时对于服务的路由都是自动创建了，减少了传统方式大量的运维配置工作。 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-6-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：Hystrix监控数据聚合【Dalston版】]]></title>
    <url>%2F2017%2F10%2F25%2Fspring-cloud-starter-dalston-5-2%2F</url>
    <content type="text"><![CDATA[上一篇我们介绍了使用Hystrix Dashboard来展示Hystrix用于熔断的各项度量指标。通过Hystrix Dashboard，我们可以方便的查看服务实例的综合情况，比如：服务调用次数、服务调用延迟等。但是仅通过Hystrix Dashboard我们只能实现对服务当个实例的数据展现，在生产环境我们的服务是肯定需要做高可用的，那么对于多实例的情况，我们就需要将这些度量指标数据进行聚合。下面，在本篇中，我们就来介绍一下另外一个工具：Turbine。 准备工作在开始使用Turbine之前，我们先回顾一下上一篇中实现的架构，如下图所示： 其中，我们构建的内容包括： eureka-server：服务注册中心 eureka-client：服务提供者 eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者 hystrix-dashboard：用于展示1234567891011121314151617181920212223242526### 动手试一试具体实现步骤如下：* 创建一个标准的Spring Boot工程，命名为：turbine。* 编辑pom.xml，具体依赖内容如下：```xml&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建应用主类1234567891011```java@Configuration@EnableAutoConfiguration@EnableTurbine@EnableDiscoveryClientpublic class TurbineApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TurbineApplication.class, args); &#125;&#125; 在123456789```propertiesspring.application.name=turbineserver.port=8989management.port=8990eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/turbine.app-config=eureka-consumer-ribbon-hystrixturbine.cluster-name-expression=&quot;default&quot;turbine.combine-host-port=true 参数说明 12345678910111213141516171819202122232425262728293031323334353637* ```turbine.cluster-name-expression``` 参数指定了集群名称为default，当我们服务数量非常多的时候，可以启动多个Turbine服务来构建不同的聚合集群，而该参数可以用来区分这些不同的聚合集群，同时该参数值可以在Hystrix仪表盘中用来定位不同的聚合集群，只需要在Hystrix Stream的URL中通过```cluster```参数来指定；* ```turbine.combine-host-port```参数设置为```true```，可以让同一主机上的服务通过主机名与端口号的组合来进行区分，默认情况下会以host来区分不同的服务，这会使得在本地调试的时候，本机上的不同服务聚合成一个服务来统计。在完成了上面的内容构建之后，我们来体验一下Turbine对集群的监控能力。分别启动```eureka-server、eureka-client、eureka-consumer-ribbon-hystrix、turbine```以及```hystrix-dashboard```。访问```Hystrix Dashboard```，并开启对http://localhost:8989/turbine.stream`的监控，这时候，我们将看到针对服务```eureka-consumer-ribbon-hystrix```的聚合监控数据。而此时的架构如下图所示：![](http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-5-2-2.png)### 通过消息代理收集聚合Spring Cloud在封装Turbine的时候，还实现了基于消息代理的收集实现。所以，我们可以将所有需要收集的监控信息都输出到消息代理中，然后Turbine服务再从消息代理中异步的获取这些监控信息，最后将这些监控信息聚合并输出到Hystrix Dashboard中。通过引入消息代理，我们的Turbine和Hystrix Dashoard实现的监控架构可以改成如下图所示的结构：![](http://blog.didispace.com/content/images/posts/spring-cloud-starter-dalston-5-2-3.png)从图中我们可以看到，这里多了一个重要元素：RabbitMQ。对于RabbitMQ的安装与基本时候我们可以查看之前的[《Spring Boot中使用RabbitMQ》](http://blog.didispace.com/spring-boot-rabbitmq/)一文，这里不做过多的说明。下面，我们可以来构建一个新的应用来实现基于消息代理的Turbine聚合服务，具体步骤如下：* 创建一个标准的Spring Boot工程，命名为：turbine-amqp。* 编辑pom.xml，具体依赖内容如下：```xml&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-turbine-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可以看到这里主要引入了123456789101112131415**注意：这里我们需要使用Java 8来运行*** 在应用主类中使用@EnableTurbineStream注解来启用Turbine Stream的配置。```java@Configuration@EnableAutoConfiguration@EnableTurbineStream@EnableDiscoveryClientpublic class TurbineApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(TurbineApplication.class, args); &#125;&#125; 配置application.properties文件： 1234spring.application.name=turbine-amqpserver.port=8989management.port=8990eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 对于Turbine的配置已经完成了，下面我们需要对服务消费者123456789```xml&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-netflix-hystrix-amqp&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 在完成了上面的配置之后，我们可以继续之前的所有项目（除turbine以外），并通过Hystrix Dashboard开启对http://localhost:8989/turbine.stream的监控，我们可以获得如之前实现的同样效果，只是这里我们的监控信息收集时是通过了消息代理异步实现的。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云：点击查看 GitHub:点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-5-2/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：Hystrix监控面板【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-5-1%2F</url>
    <content type="text"><![CDATA[在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括： eureka-server：服务注册中心 eureka-client：服务提供者 eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者 由于 eureka-consumer-ribbon-hystrix 项目中的 /consumer 接口实现使用了 @HystrixCommand 修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。 动手试一试 在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步： 创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。编辑pom.xml，具体依赖内容如下： 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 为应用主类加上@EnableHystrixDashboard，启用Hystrix Dashboard功能。 1234567@EnableHystrixDashboard@SpringCloudApplicationpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; 根据实际情况修改application.properties配置文件，比如：选择一个未被占用的端口等，此步非必须。 12spring.application.name=hystrix-dashboardserver.port=1301 到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：http://localhost:1301/hystrix，我们可以看到如下页面： 这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为： 默认的集群监控：通过URL http://turbine-hostname:port/turbine.stream 开启，实现对默认集群的监控。 指定的集群监控：通过URL http://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对 clusterName 集群的监控。 单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。 前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。 既然Hystrix Dashboard监控单实例节点需要通过访问实例的 /hystrix.stream 接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步： 在服务实例 pom.xml 中的 dependencies 节点中新增 spring-boot-starter-actuator 监控模块以开启监控相关的端点，并确保已经引入断路器的依赖 spring-cloud-starter-hystrix ： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 确保在服务实例的主类中已经使用 @EnableCircuitBreaker 或 @EnableHystrix 注解，开启了断路器功能。 到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入http://localhost:2101/hystrix.stream，已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面： 在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数： Delay ：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。 Title ：该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。 回到监控页面，我们来详细说说其中各元素的具体含义： 我们可以在监控信息的左上部分找到两个重要的图形信息：一个实心圆和一条曲线。 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。 * 曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。 其他一些数量指标如下图所示： 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-5-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix断路器）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-3%2F</url>
    <content type="text"><![CDATA[前言 在前两篇《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》和《Spring Cloud构建微服务架构：服务容错保护（Hystrix依赖隔离）》中，我们对Hystrix提供的服务降级和依赖隔离有了基本的认识。下面我们将继续说说Hystrix的另外一个重要元件：断路器。 断路器断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。 在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑，下面我们来看看它更为深层次的处理逻辑。 以在 《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》 一文中实现的服务降级例子为示例，我们来说说断路器的工作原理。当我们把服务提供者eureka-client中加入了模拟的时间延迟之后，在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积。 这个时候断路器就会发挥作用，那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是： 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。 那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回fallback，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。 在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-4-3/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix依赖隔离）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-2%2F</url>
    <content type="text"><![CDATA[前言 在上一篇《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》中，我们已经体验了如何使用@HystrixCommand来为一个依赖资源定义服务降级逻辑。实现方式非常简单，同时对于降级逻辑还能实现一些更加复杂的级联降级等策略。之前对于使用Hystrix来实现服务容错保护时，除了服务降级之外，我们还提到过线程隔离、断路器等功能。那么在本篇中我们就来具体说说线程隔离。 依赖隔离舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。 通过对依赖服务的线程池隔离实现，可以带来如下优势： 应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。 可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。 当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。 当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。 当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。 除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。 总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。 虽然线程池隔离的方案带了如此多的好处，但是很多使用者可能会担心为每一个依赖服务都分配一个线程池是否会过多地增加系统的负载和开销。对于这一点，使用者不用过于担心，因为这些顾虑也是大部分工程师们会考虑到的，Netflix在设计Hystrix的时候，认为线程池上的开销相对于隔离所带来的好处是无法比拟的。同时，Netflix也针对线程池的开销做了相关的测试，以证明和打消Hystrix实现对性能影响的顾虑。 下图是Netflix Hystrix官方提供的一个Hystrix命令的性能监控，该命令以每秒60个请求的速度（QPS）向一个单服务实例进行访问，该服务实例每秒运行的线程数峰值为350个。 比较情况 未使用线程池隔离 使用了线程池隔离 耗时差距 中位数 2ms 2ms 2ms 90百分位 5ms 8ms 3ms 99百分位 28ms 37ms 9ms 在99%的情况下，使用线程池隔离的延迟有9ms，对于大多数需求来说这样的消耗是微乎其微的，更何况为系统在稳定性和灵活性上所带来的巨大提升。虽然对于大部分的请求我们可以忽略线程池的额外开销，而对于小部分延迟本身就非常小的请求（可能只需要1ms），那么9ms的延迟开销还是非常昂贵的。实际上Hystrix也为此设计了另外的一个解决方案：信号量。 Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用： 命令执行：如果隔离策略参数execution.isolation.strategy设置为SEMAPHORE，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。 降级逻辑：当Hystrix尝试降级逻辑时候，它会在调用线程中使用信号量。 信号量的默认值为10，我们也可以通过动态刷新配置的方式来控制并发线程的数量。对于信号量大小的估算方法与线程池并发度的估算类似。仅访问内存数据的请求一般耗时在1ms以内，性能可以达到5000rps，这样级别的请求我们可以将信号量设置为1或者2，我们可以按此标准并根据实际请求耗时来设置信号量。 如何使用说了那么多依赖隔离的好处，那么我们如何使用Hystrix来实现依赖隔离呢？其实，我们在上一篇定义服务降级的时候，已经自动的实现了依赖隔离。 在上一篇的示例中，我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。除了依赖隔离、服务降级之外，还有一个重要元素：断路器。我们将在下一篇做详细的介绍，这三个重要利器构成了Hystrix实现服务容错保护的强力组合拳。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-4-2/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-1%2F</url>
    <content type="text"><![CDATA[前言在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。 接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。 动手试一试在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括： eureka-server 工程：服务注册中心，端口：1001 eureka-client 工程：服务提供者，两个实例启动端口分别为2001 下面我们可以复制一下之前实现的一个服务消费者： eureka-consumer-ribbon ，命名为 eureka-consumer-ribbon-hystrix 。下面我们开始对其进行改在： 第一步： pom.xml 的dependencies节点中引入 spring-cloud-starter-hystrix 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：在应用主类中使用@EnableCircuitBreaker或@EnableHystrix注解开启Hystrix的使用： 12345678910111213@EnableCircuitBreaker@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 注意：这里我们还可以使用Spring Cloud应用中的@SpringCloudApplication注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。 123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic @interface SpringCloudApplication &#123;&#125; 第三步：改造服务消费方式，新增 ConsumerService 类，然后将在 Controller 中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加 @HystrixCommand 注解来指定服务降级方法，比如： 1234567891011121314151617181920@RestControllerpublic class DcController &#123; @Autowired ConsumerService consumerService; @GetMapping("/consumer") public String dc() &#123; return consumerService.consumer(); &#125; class ConsumerService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public String consumer() &#123; return restTemplate.getForObject("http://eureka-client/dc", String.class); &#125; public String fallback() &#123; return "fallback"; &#125; &#125;&#125; 下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问 localhost:2101/consumer ，此时可以获取正常的返回，比如： Services: [eureka-consumer-ribbon-hystrix, eureka-client] 。 为了触发服务降级逻辑，我们可以将服务提供者 eureka-client 的逻辑加一些延迟，比如： 1234567@GetMapping("/dc")public String dc() throws InterruptedException &#123; Thread.sleep(5000L); String services = "Services: " + discoveryClient.getServices(); System.out.println(services); return services;&#125; 重启 eureka-client 之后，再尝试访问 localhost:2101/consumer ，此时我们将获得的返回结果为： fallback 。我们从 eureka-client 的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过 HystrixCommand 注解中指定的降级逻辑进行执行，因此该请求的结果返回了 fallback 。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-ribbon-hystrix 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-4-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：分布式配置中心【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-3%2F</url>
    <content type="text"><![CDATA[Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。 准备配置仓库 准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：https://gitee.com/winter_chen/config-repo 假设我们读取配置中心的应用名为 config-client，那么我们可以在git仓库中该项目的默认配置文件 config-client.yml： 12info: profile: default 为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件 config-client-dev.yml： 12info: profile: dev 构建配置中心通过Spring Cloud Config来构建一个分布式配置中心非常简单，只需要三步： 创建一个基础的Spring Boot工程，命名为： config-server-git ，并在 pom.xml 中引入下面的依赖（省略了parent和dependencyManagement部分）： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring Boot的程序主类，并添加 @EnableConfigServer 注解，开启Spring Cloud Config的服务端功能。 1234567@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 在 application.yml 中添加配置服务的基本信息以及Git仓库的相关信息，例如： 12345678910spring application: name: config-server cloud: config: server: git: uri: http://git.oschina.net/didispace/config-repo-demo/server: port: 1201 到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。 如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现；spring.cloud.config.server.git.username：访问Git仓库的用户名spring.cloud.config.server.git.password：访问Git仓库的用户密码 完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 上面的url会映射{application}-{profile}.properties对应的配置文件，其中 {label} 对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url： http://localhost:1201/config-client/dev/master ，并获得如下返回： 1234567891011121314151617181920212223&#123; "name": "config-client", "profiles": [ "dev" ], "label": "master", "version": null, "state": null, "propertySources": [ &#123; "name": "http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml", "source": &#123; "info.profile": "dev" &#125; &#125;, &#123; "name": "http://git.oschina.net/didispace/config-repo-demo/config-client.yml", "source": &#123; "info.profile": "default" &#125; &#125; ]&#125; 我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。 构建客户端在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。 创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖： 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring Boot的应用主类，具体如下： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建 bootstrap.yml 配置，来指定获取配置文件的 config-server-git 位置，例如： 12345678910spring: application: name: config-client cloud: config: uri: http://localhost:1201/ profile: default label: masterserver: port: 2001 上述配置参数与Git中存储的配置文件中各个部分的对应关系如下： spring.application.name：对应配置文件规则中的{application}部分 spring.cloud.config.profile：对应配置文件规则中的{profile}部分 spring.cloud.config.label：对应配置文件规则中的{label}部分 spring.cloud.config.uri：配置中心config-server的地址 这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载。 在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息： 123&#123; "profile": "default"&#125; 另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： 基于Git仓库的配置中心：config-server-git 使用配置中心的客户端：config-client 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-3/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java导出Excel文档（poi），并上传到腾讯云对象存储服务器]]></title>
    <url>%2F2017%2F10%2F21%2Fjava-make-excel-poi-to-upload-cloud%2F</url>
    <content type="text"><![CDATA[需求后台生成周报月报季报年报Excel，将文件下载链接推送给对应客户 开发思路：1.根据选定日期生成周报，月报，季报，年报数据2.将这些数据报告生成Excel表格3.把生成的文件上传到腾讯云对象存储服务器4.将服务器返回的url存储到数据库 工具poi-3.14-20160307.jar(点击可下载) 数据获取数据部分省略了 代码主方法1234567891011121314151617public boolean addReportExcelToCloud(ReportResult rr) &#123; OutputStream out = new ByteArrayOutputStream(); ExcelProjectUtils eu = new ExcelProjectUtils(); eu.exportExcel(rr, out); //&lt;1&gt; ConvertUtil cu = new ConvertUtil(); try &#123; ByteArrayInputStream byteInput = cu.parse(out); String rs = PicUploadToYun.uploadExcel(SysContent.getFileRename("案场数据报.xls"), byteInput); //&lt;2&gt; addReportExcelToDB(rr, rs); //&lt;3&gt; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 将数据生成二进制Excel文件 (方法详细见下面代码) 将生成的二进制文件上传到腾讯云对象存储服务器 (方法详细见下面代码) 将服务器返回的url存储到数据库 (方法详细见下面代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392/** * 周报年报生成excel * * @param report * @param out */ public void exportExcel(ReportResult report, OutputStream out) &#123; // 判断传入的时间间隔 String dateStr = ""; String reportName = ""; List&lt;String&gt; dateCount = DateUtil.getTwoDateEveryDay(report.getStartTime(), report.getEndTime()); if (dateCount.size() &lt;= 7) &#123; dateStr += "本周"; reportName += "案场周报"; &#125; else if (dateCount.size() &gt;= 28 &amp;&amp; dateCount.size() &lt;= 31) &#123; dateStr += "本月"; reportName += "案场月报"; &#125; else if (dateCount.size() &gt;= 85 &amp;&amp; dateCount.size() &lt;= 100) &#123; dateStr += "本季度"; reportName += "案场季报"; &#125; else if (dateCount.size() &gt;= 180 &amp;&amp; dateCount.size() &lt;= 185) &#123; dateStr += "本半年度"; reportName += "案场半年报"; &#125; else if (dateCount.size() &gt;= 360 &amp;&amp; dateCount.size() &lt;= 367) &#123; dateStr += "本年度"; reportName += "案场年报"; &#125; else &#123; dateStr += "时间段内"; reportName += "案场阶段报"; &#125; report.setReportName(reportName); // 声明一个工作薄 HSSFWorkbook workbook = new HSSFWorkbook(); // 生成一个表格 HSSFSheet sheet = workbook.createSheet(report.getReportName() + report.getStartTime() + " - " + report.getEndTime()); // 设置表格默认列宽度为100个字节 sheet.setDefaultColumnWidth((short) 100); /** ----------样式一：标题 ------------ **/ HSSFCellStyle style = workbook.createCellStyle(); // 设置这些样式 style.setBorderLeft(HSSFCellStyle.BORDER_THIN); style.setBorderRight(HSSFCellStyle.BORDER_THIN); //style.setBorderTop(HSSFCellStyle.BORDER_THIN); style.setAlignment(HSSFCellStyle.ALIGN_CENTER); // 生成一个字体 HSSFFont font = workbook.createFont(); font.setFontName("宋体"); //font.setColor(HSSFColor.VIOLET.index); font.setFontHeightInPoints((short) 14); font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 把字体应用到当前的样式 style.setFont(font); /***---------样式二：小标题---------***/ HSSFCellStyle style2 = workbook.createCellStyle(); style2.setBorderLeft(HSSFCellStyle.BORDER_THIN); style2.setBorderRight(HSSFCellStyle.BORDER_THIN); //style2.setBorderTop(HSSFCellStyle.BORDER_THIN); style2.setAlignment(HSSFCellStyle.ALIGN_LEFT); //style2.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); // 生成另一个字体 HSSFFont font2 = workbook.createFont(); //font2.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL); font2.setFontName("宋体"); font2.setFontHeightInPoints((short) 11); font2.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 把字体应用到当前的样式 style2.setFont(font2); /*** 样式三：右侧日期 ***/ HSSFCellStyle style3 = workbook.createCellStyle(); //样式 style3.setBorderLeft(HSSFCellStyle.BORDER_THIN); style3.setBorderRight(HSSFCellStyle.BORDER_THIN); style3.setAlignment(HSSFCellStyle.ALIGN_RIGHT); style3.setBorderBottom(HSSFCellStyle.BORDER_THIN); //字体 HSSFFont font3 = workbook.createFont(); font3.setFontName("宋体"); font3.setFontHeightInPoints((short) 11); style3.setFont(font3); /** 样式四：主内容 ***/ HSSFCellStyle style4 = workbook.createCellStyle(); //样式 style4.setBorderLeft(HSSFCellStyle.BORDER_THIN); style4.setBorderRight(HSSFCellStyle.BORDER_THIN); style4.setAlignment(HSSFCellStyle.ALIGN_LEFT); //字体 HSSFFont font4 = workbook.createFont(); font4.setFontName("宋体"); font4.setFontHeightInPoints((short) 11); style4.setFont(font4); /** 样式五：底侧空内容 ***/ HSSFCellStyle style5 = workbook.createCellStyle(); //样式 style5.setBorderLeft(HSSFCellStyle.BORDER_THIN); style5.setBorderRight(HSSFCellStyle.BORDER_THIN); style5.setAlignment(HSSFCellStyle.ALIGN_LEFT); style5.setBorderBottom(HSSFCellStyle.BORDER_THIN); //字体 HSSFFont font5 = workbook.createFont(); font5.setFontName("宋体"); font5.setFontHeightInPoints((short) 11); style5.setFont(font5); // 声明一个画图的顶级管理器 HSSFPatriarch patriarch = sheet.createDrawingPatriarch(); // 定义注释的大小和位置,详见文档 HSSFComment comment = patriarch.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short) 4, 2, (short) 6, 5)); // 设置注释内容 comment.setString(new HSSFRichTextString("数据报")); // 设置注释作者，当鼠标移动到单元格上是可以在状态栏中看到该内容. comment.setAuthor("saas"); // 产生表格标题行 -- 项目名称 HSSFRow row = sheet.createRow(0); createCellAndRow(style4, report.getProjectName(), row); // 产生表格标题行 -- 周报名称 row = sheet.createRow(1); createCellAndRow(style, report.getReportName(), row); // 产生表格标题行 -- 起始时间-终止时间 row = sheet.createRow(2); String startTime = DateUtil.format(DateUtil.parse(report.getStartTime(), DateUtil.PATTERN_CLASSICAL_SIMPLE), DateUtil.PATTERN_CLASSICAL_SIMPLE_YMD); String endTime = DateUtil.format(DateUtil.parse(report.getEndTime(), DateUtil.PATTERN_CLASSICAL_SIMPLE), DateUtil.PATTERN_CLASSICAL_SIMPLE_YMD); String date = "日期：" + startTime + " - " + endTime; createCellAndRow(style3, date, row); // 接访情况标题 row = sheet.createRow(3); createCellAndRow(style2, "·接访情况", row); // 接访客户组数 row = sheet.createRow(4); Integer visitCount = report.getVisitCount(); String visitNum = "1、" + dateStr + "共计接访客户" + visitCount + "组，来访量"; if (visitCount &lt; 40) &#123; visitNum += "较少，有待提升"; &#125; else if (visitCount &gt;= 41 &amp;&amp; visitCount &lt;= 99) &#123; visitNum += "尚可，还有提高空间"; &#125; else if (visitCount &gt;= 100 &amp;&amp; visitCount &lt;= 139) &#123; visitNum += "很多"; &#125; else if (visitCount &gt; 140) &#123; visitNum += "火爆"; &#125; createCellAndRow(style4, visitNum, row); // 有效接访率 row = sheet.createRow(5); Double visitRate = new Double(report.getValidVisitRate()); String visitRateStr = "2、有效接访率为" + visitRate + "%，接访成效"; if (visitRate &lt; 50) &#123; visitRateStr += "较低，有待提升"; &#125; else if (visitRate &gt;= 50 &amp;&amp; visitRate &lt;= 65) &#123; visitRateStr += "尚可，还有提高空间"; &#125; else if (visitRate &gt;= 65 &amp;&amp; visitRate &lt;= 80) &#123; visitRateStr += "很高"; &#125; else if (visitRate &gt; 80) &#123; visitRateStr += "极高"; &#125; createCellAndRow(style4, visitRateStr, row); // 首访有效率 row = sheet.createRow(6); Double newVisitRate = new Double(report.getValidNewCuVisitRate()); String newVisitStr = "3、首访有效率为" + newVisitRate + "%，来访转储客的概率"; if (newVisitRate &lt; 40) &#123; newVisitStr += "较差，有待提升"; &#125; else if (newVisitRate &gt;= 40 &amp;&amp; newVisitRate &lt;= 60) &#123; newVisitStr += "尚可，还有提高空间"; &#125; else if (newVisitRate &gt;= 60 &amp;&amp; newVisitRate &lt;= 75) &#123; newVisitStr += "很高"; &#125; else if (newVisitRate &gt; 75) &#123; newVisitStr += "极高"; &#125; createCellAndRow(style4, newVisitStr, row); // 老客户接访占比 row = sheet.createRow(7); Double oldVisitRate = new Double(report.getOldCuVisitRate()); String oldVisitStr = "4、老客户接访比为" + oldVisitRate + "%，老客户接访的占比"; if (oldVisitRate &lt; 20) &#123; oldVisitStr += "较低"; &#125; else if (oldVisitRate &gt;= 20 &amp;&amp; oldVisitRate &lt;= 40) &#123; oldVisitStr += "尚可"; &#125; else if (oldVisitRate &gt;= 40 &amp;&amp; oldVisitRate &lt;= 60) &#123; oldVisitStr += "很高"; &#125; else if (oldVisitRate &gt; 60) &#123; oldVisitStr += "极高"; &#125; createCellAndRow(style4, oldVisitStr, row); //空行 row = sheet.createRow(8); createCellAndRow(style4, "", row); // 储客情况 row = sheet.createRow(9); createCellAndRow(style2, "·储客情况", row); // 新增储客 row = sheet.createRow(10); Integer newCuCount = report.getNewCuCount(); String newCuStr = "1、" + dateStr + "新增储客" + newCuCount + "组，新增量"; if (newCuCount &lt; 30) &#123; newCuStr += "较少，有待提升"; &#125; else if (newCuCount &gt;= 31 &amp;&amp; newCuCount &lt;= 60) &#123; newCuStr += "尚可，还有提高空间"; &#125; else if (newCuCount &gt;= 61 &amp;&amp; newCuCount &lt;= 79) &#123; newCuStr += "很多"; &#125; else if (newCuCount &gt; 80) &#123; newCuStr += "爆满"; &#125; createCellAndRow(style4, newCuStr, row); // 累计老客户 row = sheet.createRow(11); Integer oldCuCount = report.getTotalOldCuCount(); Integer totalCuCount = report.getTotalCuCount(); Double oldCuRate = new Double(SysContent.getTwoNumberForValue(oldCuCount, totalCuCount)); String oldCuStr = "2、累计老客户总量为" + oldCuCount + "组，老客户占比为" + oldCuRate + "%，显示老客户关注度"; if (oldCuRate &lt; 15) &#123; oldCuStr += "较低，有待提升"; &#125; else if (oldCuRate &gt;= 15 &amp;&amp; oldCuRate &lt;= 25) &#123; oldCuStr += "尚可，还有提高空间"; &#125; else if (oldCuRate &gt;= 25 &amp;&amp; oldCuRate &lt;= 40) &#123; oldCuStr += "很高"; &#125; else if (oldCuRate &gt; 40) &#123; oldCuStr += "极高"; &#125; createCellAndRow(style4, oldCuStr, row); // 累计总储客 row = sheet.createRow(12); String totalOldCuStr = "3、累计总储客" + totalCuCount + "组"; createCellAndRow(style4, totalOldCuStr, row); // 成交情况(周报没有，其他有) if (report.getSubscribeHouseCount() != null) &#123; //空行 row = sheet.createRow(13); createCellAndRow(style4, "", row); row = sheet.createRow(14); createCellAndRow(style2, "·成交情况", row); // 新增认购套数 row = sheet.createRow(15); Integer subscribeHouseCount = report.getSubscribeHouseCount(); Double subscribeHouseRate = new Double(report.getSubscribeHouseRate()); String subscribeHouseStr = "1、" + dateStr + "新增认购套数" + subscribeHouseCount + "套，较" + dateStr + "同期"; if (subscribeHouseRate &lt; 0) &#123; subscribeHouseStr += "减少"; &#125; else &#123; subscribeHouseStr += "增长"; &#125; subscribeHouseStr += Math.abs(subscribeHouseRate) + "%"; createCellAndRow(style4, subscribeHouseStr, row); // 新增认购金额 row = sheet.createRow(16); Long subscribeMoney = report.getSubscribeMoney(); Double subscribeMoneyRate = new Double(report.getSubscribeMoneyRate()); String subscribeMoneyStr = " 新增认购金额" + subscribeMoney + "万元，较" + dateStr + "同期"; if (subscribeHouseRate &lt; 0) &#123; subscribeMoneyStr += "减少"; &#125; else &#123; subscribeMoneyStr += "增长"; &#125; subscribeMoneyStr += Math.abs(subscribeMoneyRate) + "%"; createCellAndRow(style4, subscribeMoneyStr, row); // 新增签约套数 row = sheet.createRow(17); Integer signCount = report.getSignCount(); Double signRate = new Double(report.getSignRate()); String signStr = "2、新增签约套数" + signCount + "套,较" + dateStr + "同期"; if (signRate &lt; 0) &#123; signStr += "减少"; &#125; else &#123; signStr += "增长"; &#125; signStr += Math.abs(signRate) + "%"; createCellAndRow(style4, signStr, row); // 新增签约金额 row = sheet.createRow(18); Long signHouseMoney = report.getSignHouseMoney(); Double signHouseMoneyRate = new Double(report.getSignHouseMoneyRate()); String signHouseMoneyStr = " 新增签约金额" + signHouseMoney + "万元，较" + dateStr + "同期"; if (signHouseMoneyRate &lt; 0) &#123; signHouseMoneyStr += "减少"; &#125; else &#123; signHouseMoneyStr += "增长"; &#125; signHouseMoneyStr += Math.abs(signHouseMoneyRate) + "%"; createCellAndRow(style4, signHouseMoneyStr, row); // 新接访签约率 row = sheet.createRow(19); Double newCustomerSignedRate = new Double(report.getNewCustomerSignedRate()); String newCustomerSignedStr = "3、" + dateStr + "新客户接访签约率" + newCustomerSignedRate + "%，接访签约概率"; if (newCustomerSignedRate &lt; 4) &#123; newCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (newCustomerSignedRate &gt;= 4 &amp;&amp; newCustomerSignedRate &lt;= 6) &#123; newCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (newCustomerSignedRate &gt;= 6 &amp;&amp; newCustomerSignedRate &lt;= 7) &#123; newCustomerSignedStr += "很高"; &#125; else if (newCustomerSignedRate &gt; 7) &#123; newCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, newCustomerSignedStr, row); // 储客签约率 row = sheet.createRow(20); Double momeryCustomerSignedRate = new Double(report.getMomeryCustomerSignedRate()); String momeryCustomerSignedStr = "4、储客签约率" + momeryCustomerSignedRate + "%，储备客户签约概率"; if (momeryCustomerSignedRate &lt; 7) &#123; momeryCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (momeryCustomerSignedRate &gt;= 7 &amp;&amp; momeryCustomerSignedRate &lt;= 12) &#123; momeryCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (momeryCustomerSignedRate &gt;= 12 &amp;&amp; momeryCustomerSignedRate &lt;= 15) &#123; momeryCustomerSignedStr += "很高"; &#125; else if (momeryCustomerSignedRate &gt; 15) &#123; momeryCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, momeryCustomerSignedStr, row); // 老客户签约率 row = sheet.createRow(21); Double oldCustomerSignedRate = new Double(report.getOldCustomerSignedRate()); String oldCustomerSignedStr = "5、老客户签约率为23.2%，高意向客户签约概率"; if (oldCustomerSignedRate &lt; 25) &#123; oldCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (oldCustomerSignedRate &gt;= 25 &amp;&amp; oldCustomerSignedRate &lt;= 35) &#123; oldCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (oldCustomerSignedRate &gt;= 35 &amp;&amp; oldCustomerSignedRate &lt;= 50) &#123; oldCustomerSignedStr += "很高"; &#125; else if (oldCustomerSignedRate &gt; 50) &#123; oldCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, oldCustomerSignedStr, row); // 认购客户签约率 row = sheet.createRow(22); Double contratCuSignedRate = new Double(report.getContratCuSignedRate()); String contratCuSignedStr = "6、认购客户签约率为92%，已认购客户签约率"; if (contratCuSignedRate &lt; 95) &#123; contratCuSignedStr += "不高，较多退订或拒签"; &#125; else if (contratCuSignedRate &gt;= 95 &amp;&amp; contratCuSignedRate &lt;= 97) &#123; contratCuSignedStr += "尚可，一定数量退订或拒签"; &#125; else if (contratCuSignedRate &gt;= 97 &amp;&amp; contratCuSignedRate &lt;= 99) &#123; contratCuSignedStr += "很高"; &#125; else if (contratCuSignedRate &gt; 99) &#123; contratCuSignedStr += "非常高"; &#125; createCellAndRow(style4, contratCuSignedStr, row); //空行 row = sheet.createRow(23); createCellAndRow(style4, "", row); //底侧 row = sheet.createRow(24); createCellAndRow(style5, "", row); &#125;else&#123; row = sheet.createRow(13); createCellAndRow(style5, "", row); &#125; try &#123; workbook.write(out); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void createCellAndRow(HSSFCellStyle style, String text, HSSFRow row) &#123; HSSFCell cell = row.createCell(0); cell.setCellStyle(style); HSSFRichTextString rs = new HSSFRichTextString(text); cell.setCellValue(rs); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 上传Excel * @param fileNewName * @param uploadFile * @return */ public static String uploadExcel(String fileNewName,ByteArrayInputStream uploadFile)&#123; // 设置用户属性, 包括appid, secretId和SecretKey // 这些属性可以通过cos控制台获取(https://console.qcloud.com/cos) String version = PropertiesUtil.getValue("version"); long appId = "你的appId"; String secretId = "你的secretId "; String secretKey = "你的secretKey "; // 设置要操作的bucket String bucketName = "root"; // 初始化客户端配置 ClientConfig clientConfig = new ClientConfig(); // 设置bucket所在的区域，比如广州(gz), 天津(tj) clientConfig.setRegion("sh"); // 初始化秘钥信息 Credentials cred = new Credentials(appId, secretId, secretKey); // 初始化cosClient COSClient cosClient = new COSClient(clientConfig, cred); // 文件操作 // // 1. 上传文件(默认不覆盖) // 将本地的local_file_1.txt上传到bucket下的根分区下,并命名为sample_file.txt // 默认不覆盖, 如果cos上已有文件, 则返回错误 String cosFilePath = "/report/" + fileNewName; byte[] localFilePath1 = null; try &#123; localFilePath1 = ConvertUtil.toByteArray(uploadFile); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; UploadFileRequest uploadFileRequest = new UploadFileRequest(bucketName, cosFilePath, localFilePath1); uploadFileRequest.setEnableShaDigest(false); String uploadFileRet = cosClient.uploadFile(uploadFileRequest); System.out.println("upload file ret:" + uploadFileRet); //获取保存路径 ObjectMapper om = new ObjectMapper(); HashMap map = new HashMap&lt;&gt;(); try &#123; map = om.readValue(uploadFileRet, HashMap.class); &#125; catch (JsonParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; HashMap&lt;String, String&gt; value = (HashMap&lt;String, String&gt;) map.get("data"); return value.get("source_url"); &#125; 123456789101112131415161718192021222324252627282930313233343536public boolean addReportExcelToDB(ReportResult rr, String url) &#123; if(StringUtils.isEmpty(url))&#123; return false; &#125; if(rr == null)&#123; return false; &#125; ProjectReportRecord prr = new ProjectReportRecord(); prr.setCreateTime(DateUtil.format(new Date())); prr.setProjectId(rr.getProjectId()); prr.setProjectName(rr.getProjectName()); prr.setStartTime(rr.getStartTime()); prr.setEndTime(rr.getEndTime()); prr.setUrl(url); String report = ""; if("案场周报".equals(rr.getReportName()))&#123; report = "week"; &#125;else if("案场月报".equals(rr.getReportName()))&#123; report = "month"; &#125;else if("案场季报".equals(rr.getReportName()))&#123; report = "quarter"; &#125;else if("案场半年报".equals(rr.getReportName()))&#123; report = "half"; &#125;else if("案场年报".equals(rr.getReportName()))&#123; report = "year"; &#125;else&#123; report = "other"; &#125; prr.setReportName(report); baseDao.save(prr); return true; &#125; 生成的文件示例周报或者其他报告都是后台自动根据时间进行判断的 周报 季报 以上]]></content>
      <categories>
        <category>JavaUtils</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Feign）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-3%2F</url>
    <content type="text"><![CDATA[通过前两篇《Spring Cloud构建微服务架构：服务消费（基础）》和《Spring Cloud构建微服务架构：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign。 Spring Cloud Feign Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能： 12345678@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子： 12345@FeignClient("eureka-client")public interface DcClient &#123; @GetMapping("/dc") String consumer();&#125; 修改Controller。通过定义的feign客户端来调用服务提供方的接口： 123456789@RestControllerpublic class DcController &#123; @Autowired DcClient dcClient; @GetMapping("/consumer") public String dc() &#123; return dcClient.consumer(); &#125;&#125; 通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费ureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-feign 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-3/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Ribbon）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-2%2F</url>
    <content type="text"><![CDATA[通过上一篇《Spring Cloud构建微服务架构：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon。 Spring Cloud RibbonSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。 我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。 下面我们通过具体的例子来看看如何使用Spring Cloud Ribbon来实现服务的调用以及客户端均衡负载。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。为RestTemplate增加@LoadBalanced注解： 123456789101112@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。 12345678910@RestControllerpublic class DcController &#123; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; return restTemplate.getForObject("http://eureka-client/dc", String.class); &#125;&#125; 可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-ribbon 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-2/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（基础）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-1%2F</url>
    <content type="text"><![CDATA[通过上一篇 《Spring Cloud构建微服务架构：服务注册与发现》，我们已经成功地将服务提供者：eureka-client或consul-client注册到了Eureka服务注册中心或Consul服务端上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务提供者的接口？ 使用LoadBalancerClient在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。 从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。 下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。 我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）： 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.properties，指定eureka注册中心的地址： 123spring.application.name=eureka-consumerserver.port=2101eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。 1234567891011@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个接口用来消费eureka-client提供的接口： 1234567891011121314@RestControllerpublic class DcController &#123; @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; ServiceInstance serviceInstance = loadBalancerClient.choose("eureka-client"); String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/dc"; System.out.println(url); return restTemplate.getForObject(url, String.class); &#125;&#125; 可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用estTemplate对象实现对服务提供者接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。 consul版的示例，可查看git仓库中的consul-client和consul-consumer更多Spring Cloud内容请持续关注我的博客更新或在《Spring Cloud微服务实战》中获取。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer consul的服务提供方：consul-client consul的服务消费者：consul-consumer 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务注册与发现（Eureka、Consul）【Dalston版】]]></title>
    <url>%2F2017%2F09%2F27%2Fspring-cloud-starter-dalston-1%2F</url>
    <content type="text"><![CDATA[Spring Cloud简介Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。 微服务架构“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的开源产品被反复的提及（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。 那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。 对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》（中文版翻译点击查看），本文不做更多的介绍和描述。 服务治理在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。 由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。 所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。 Spring Cloud Eureka首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。 Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。 下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。 创建“服务注册中心”创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子12345678@EnableEurekaServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class) .web(true).run(args); &#125;&#125; 在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：12345spring.application.name=eureka-serverserver.port=1001eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：http://localhost:1001/，可以看到下面的页面，其中还没有发现任何服务。 创建“服务提供方”下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。 首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。1234567891011@RestControllerpublic class DcController &#123; @Autowired DiscoveryClient discoveryClient; @GetMapping("/dc") public String dc() &#123; String services = "Services: " + discoveryClient.getServices(); System.out.println(services); return services; &#125;&#125; 最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。123456789@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder( ComputeServiceApplication.class) .web(true).run(args); &#125;&#125; 我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：123spring.application.name=eureka-clientserver.port=2001eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。 启动该工程后，再次访问：http://localhost:1001/。可以如下图内容，我们定义的服务被成功注册了。当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：http://localhost:2001/dc，我们可以得到如下输出返回：1Services: [eureka-client] 其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中区。 Spring Cloud ConsulSpring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性： 服务发现 健康检查 Key/Value存储 多数据中心由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。 以之前实现的基于Eureka的示例（eureka-client）为基础，我们如何将之前实现的服务提供者注册到Consul上呢？方法非常简单，我们只需要在pom.xml中将eureka的依赖修改为如下依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 接下来再修改一下application.properites，将consul需要的配置信息加入即可，比如：（下面配置是默认值）12spring.cloud.consul.host=localhostspring.cloud.consul.port=8500 到此为止，我们将eureka-client转换为基于consul服务治理的服务提供者就完成了。前文我们已经有提到过服务发现的接口DiscoveryClient是Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，我们的程序不需要做任何改变，只需要引入不同的服务治理依赖，并配置相关的配置属性就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。下面可以尝试让consul的服务提供者运行起来。这里可能读者会问，不需要创建类似eureka-server的服务端吗？由于Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。 我们可以用下面的命令启动consul的开发模式：1234567891011121314151617181920212223242526272829303132$consul agent -dev==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running! Version: &apos;v0.7.2&apos; Node name: &apos;Lenovo-zhaiyc&apos; Datacenter: &apos;dc1&apos; Server: true (bootstrap: false) Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400) Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302) Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false Atlas: &lt;disabled&gt;==&gt; Log data will now stream in as it occurs: 2017/06/22 07:50:54 [INFO] raft: Initial configuration (index=1): [&#123;Suffrage:Voter ID:127.0.0.1:8300 Address:127.0.0.1:8300&#125;] 2017/06/22 07:50:54 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &quot;&quot;) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding LAN server Lenovo-zhaiyc (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc.dc1 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding WAN server Lenovo-zhaiyc.dc1 (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:51:01 [ERR] agent: failed to sync remote state: No cluster leader 2017/06/22 07:51:02 [WARN] raft: Heartbeat timeout from &quot;&quot; reached, starting election 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2 2017/06/22 07:51:02 [DEBUG] raft: Votes needed: 1 2017/06/22 07:51:02 [DEBUG] raft: Vote granted from 127.0.0.1:8300 in term 2. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Election won. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state 2017/06/22 07:51:02 [INFO] consul: cluster leadership acquired 2017/06/22 07:51:02 [INFO] consul: New leader elected: Lenovo-zhaiyc 2017/06/22 07:51:02 [DEBUG] consul: reset tombstone GC to index 3 2017/06/22 07:51:02 [INFO] consul: member &apos;Lenovo-zhaiyc&apos; joined, marking health alive 2017/06/22 07:51:02 [INFO] agent: Synced service &apos;consul&apos; 2017/06/22 07:51:02 [DEBUG] agent: Node info in sync consul服务端启动完成之后，我们再将之前改造后的consul服务提供者启动起来。consul与eureka一样，都提供了简单的ui界面来查看服务的注册情况： 更多关于Consul的使用指南，读者可查看官方文档：https://www.consul.io/ 代码示例 码云：点击查看 GitHub：点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client consul的服务提供方：consul-client 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Eureka</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中使用log4j详细配置]]></title>
    <url>%2F2017%2F09%2F26%2Fspring-log4j%2F</url>
    <content type="text"><![CDATA[第一步：导入log4j-1.2.17.jar包。第二步：src同级创建并设置log4j.properties。 log4j.properties的详细配置：123456789101112131415161718192021222324 ### 设置 ###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 更详细的log4j.properties配置 第三步：web.xml中加入配置详细： 1234567891011121314&lt;!-- 设置根目录 --&gt; &lt;!--初始化log4j.properties--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;3000&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; applicationContext.xml就不需要配置了 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.2.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;/beans&gt; 然后日志就可以随着spring的启动而启动了。 如果想把日志文件打印到Tomcat日志文件中：log4j.appender.R.File=${catalina.home}/logs/youLogFile.log 这个方法只能Tomcat使用，其它容器就不行了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mysql存入大量TEXT类型的数据报错]]></title>
    <url>%2F2017%2F09%2F26%2Fmysql-text%2F</url>
    <content type="text"><![CDATA[主要的原因是因为max_sort_length的默认值为1024,=解决办法：该参数是动态参数，任何客户端都可以在Mysql数据库运行时更改该参数的值，例如：1.首先应该查询一下这个参数的默认值为多少1mysql&gt; SELECT @@global.max_sort_length; 2.然后去设置这个值： 1mysql&gt; SET GLOBAL max_sort_length=2048; //2048这个数值由你了 3.然后再查询一下这个参数的默认值：1mysql&gt; SELECT @@global.max_sort_length; 以上问题就解决了]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot Mybatis 整合（完整版）]]></title>
    <url>%2F2017%2F09%2F25%2Fspringboot-mybatis%2F</url>
    <content type="text"><![CDATA[本项目使用的环境： 开发工具：Intellij IDEA 2017.1.3 jdk：1.7.0_79 3.maven:3.3.9 额外功能 PageHelper 分页插件 mybatis generator 自动生成代码插件 步骤：1.创建一个springboot项目：2.创建项目的文件结构以及jdk的版本3.选择项目所需要的依赖然后点击finish 5.看一下文件的结构： 6.查看一下pom.xml： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.winter&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-mybatis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 7.项目不使用application.properties文件 而使用更加简洁的application.yml文件：将原有的resource文件夹下的application.properties文件删除，创建一个新的application.yml配置文件，文件的内容如下：123456789101112131415161718192021222324252627282930313233343536server: port: 8080spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/depot username: root password: root # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20mybatis: mapper-locations: classpath:mapping/*.xml type-aliases-package: com.winter.model#pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 8.创建数据库： 12345678CREATE DATABASE mytest;CREATE TABLE t_user( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(255) NOT NULL , password VARCHAR(255) NOT NULL , phone VARCHAR(255) NOT NULL) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 9.使用mybatis generator 自动生成代码： a.配置pom.xml中generator 插件所对应的配置文件 ${basedir}/src/main/resources/generator/generatorConfig.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="E:\developer\mybatis-generator-core-1.3.2\lib\mysql-connector-java-5.1.25-bin.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1/mytest" userId="root" password="root"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="main.java.com.winter.model" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="main.resources.mapping" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="main.java.com.winter.mapper" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="t_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; b.点击run-Edit Configurations c.添加配置 d.运行 最后生成的文件以及结构： 10.我们还需要修改有点东西，因为生成的类中的路径写了全路径，所以我们要把前面多余的删掉： UserMapper.java 12345678910111213141516171819package com.winter.mapper;import com.winter.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer userId); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer userId); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); //这个方式我自己加的 List&lt;User&gt; selectAllUser();&#125; User.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.winter.model;public class User &#123; private Integer userId; private String userName; private String password; private String phone; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone == null ? null : phone.trim(); &#125;&#125; 对于映射文件xml有一个快捷的方式把所有德多余的代码一次删掉： Ctrl+F 进行搜索“main.java.”: 对于sql语句这种黄色的背景，真心是看不下去了（解决方案）： UserMapper.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.winter.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.winter.model.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;!-- 这个方法是我自己加的 --&gt; &lt;select id="selectAllUser" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from t_user &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.winter.model.User" &gt; insert into t_user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.winter.model.User" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.winter.model.User" &gt; update t_user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.winter.model.User" &gt; update t_user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; 11.打开类SpringbootMybatisDemoApplication.java，这个是springboot的启动类。我们需要添加点东西： 1234567891011121314package com.winter;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.winter.mapper")//将项目中对应的mapper类的路径加进来就可以了public class SpringbootMybatisDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisDemoApplication.class, args); &#125;&#125; 12.到这里所有的搭建工作都完成了，接下来就是测试的工作，没使用junit4进行测试：首先看一下完成之后的文件的结构： 现在controller，service层的代码都写好： UserController.java 1234567891011121314151617181920212223242526272829303132package com.winter.Controller;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * Created by Administrator on 2017/8/16. */@Controller@RequestMapping(value = "/user")public class UserController &#123; @Autowired private UserService userService; @ResponseBody @RequestMapping(value = "/add", produces = &#123;"application/json;charset=UTF-8"&#125;) public int addUser(User user)&#123; return userService.addUser(user); &#125; @RequestMapping(value = "/all/&#123;pageNum&#125;/&#123;pageSize&#125;", produces = &#123;"application/json;charset=UTF-8"&#125;) public Object findAllUser(@PathVariable("pageNum") int pageNum, @PathVariable("pageSize") int pageSize)&#123; return userService.findAllUser(pageNum,pageSize); &#125;&#125; UserService.java 123456789101112131415package com.winter.service;import com.winter.model.User;import java.util.List;/** * Created by Administrator on 2017/8/16. */public interface UserService &#123; int addUser(User user); List&lt;User&gt; findAllUser(int pageNum, int pageSize);&#125; UserServiceImpl.java 123456789101112131415161718192021222324252627282930313233343536373839package com.winter.service.impl;import com.github.pagehelper.PageHelper;import com.winter.mapper.UserMapper;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * Created by Administrator on 2017/8/16. */@Service(value = "userService")public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper;//这里会报错，但是并不会影响 @Override public int addUser(User user) &#123; return userMapper.insertSelective(user); &#125; /* * 这个方法中用到了我们开头配置依赖的分页插件pagehelper * 很简单，只需要在service层传入参数，然后将参数传递给一个插件的一个静态方法即可； * pageNum 开始页数 * pageSize 每页显示的数据条数 * */ @Override public List&lt;User&gt; findAllUser(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 PageHelper.startPage(pageNum, pageSize); return userMapper.selectAllUser(); &#125;&#125; 如果强迫症看不下去那个报错：（解决方法） 测试我使用了idea一个很用心的功能。可以发http请求的插件： 点击左侧的运行按钮就可以发送请求了；如果返回值正确 说明你已经搭建成功了！！ 源码地址：https://github.com/WinterChenS/springboot-mybatis-demo]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java优雅的输出helloWorld]]></title>
    <url>%2F2017%2F09%2F25%2Fjava-print-helloworld%2F</url>
    <content type="text"><![CDATA[在java中很优雅的输出helloworld，可以试一试1234567891011121314151617public class Test&#123; public static void main(String[] args) &#123; System.out.println(randomString(-229985452) + " " + randomString(-147909649)); &#125; public static String randomString(int seed)&#123; Random rand = new Random(seed); StringBuilder sb = new StringBuilder(); while(true)&#123; int n = rand.nextInt(27); if(n==0) break; sb.append((char)('`'+n)); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
