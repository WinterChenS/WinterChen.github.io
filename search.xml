<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Ribbon）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-2%2F</url>
    <content type="text"><![CDATA[通过上一篇《Spring Cloud构建微服务架构：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon。 Spring Cloud RibbonSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。 我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。 下面我们通过具体的例子来看看如何使用Spring Cloud Ribbon来实现服务的调用以及客户端均衡负载。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。为RestTemplate增加@LoadBalanced注解： 123456789101112@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。 12345678910@RestControllerpublic class DcController &#123; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; return restTemplate.getForObject("http://eureka-client/dc", String.class); &#125;&#125; 可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-ribbon]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Feign）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-3%2F</url>
    <content type="text"><![CDATA[通过前两篇《Spring Cloud构建微服务架构：服务消费（基础）》和《Spring Cloud构建微服务架构：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign。 Spring Cloud Feign Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能： 12345678@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子： 12345@FeignClient("eureka-client")public interface DcClient &#123; @GetMapping("/dc") String consumer();&#125; 修改Controller。通过定义的feign客户端来调用服务提供方的接口： 123456789@RestControllerpublic class DcController &#123; @Autowired DcClient dcClient; @GetMapping("/consumer") public String dc() &#123; return dcClient.consumer(); &#125;&#125; 通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费ureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-feign]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（基础）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-1%2F</url>
    <content type="text"><![CDATA[通过上一篇 《Spring Cloud构建微服务架构：服务注册与发现》，我们已经成功地将服务提供者：eureka-client或consul-client注册到了Eureka服务注册中心或Consul服务端上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务提供者的接口？ 使用LoadBalancerClient在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。 从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。 下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。 我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）： 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.properties，指定eureka注册中心的地址： 123spring.application.name=eureka-consumerserver.port=2101eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。 1234567891011@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个接口用来消费eureka-client提供的接口： 1234567891011121314@RestControllerpublic class DcController &#123; @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; ServiceInstance serviceInstance = loadBalancerClient.choose("eureka-client"); String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/dc"; System.out.println(url); return restTemplate.getForObject(url, String.class); &#125;&#125; 可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用estTemplate对象实现对服务提供者接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。 consul版的示例，可查看git仓库中的consul-client和consul-consumer更多Spring Cloud内容请持续关注我的博客更新或在《Spring Cloud微服务实战》中获取。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer consul的服务提供方：consul-client consul的服务消费者：consul-consumer 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务注册与发现（Eureka、Consul）【Dalston版】]]></title>
    <url>%2F2017%2F09%2F27%2Fspring-cloud-starter-dalston-1%2F</url>
    <content type="text"><![CDATA[Spring Cloud简介Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。 微服务架构“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的开源产品被反复的提及（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。 那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。 对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》（中文版翻译点击查看），本文不做更多的介绍和描述。 服务治理在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。 由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。 所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。 Spring Cloud Eureka首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。 Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。 下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。 创建“服务注册中心”创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子12345678@EnableEurekaServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class) .web(true).run(args); &#125;&#125; 在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：12345spring.application.name=eureka-serverserver.port=1001eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：http://localhost:1001/，可以看到下面的页面，其中还没有发现任何服务。 创建“服务提供方”下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。 首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。1234567891011@RestControllerpublic class DcController &#123; @Autowired DiscoveryClient discoveryClient; @GetMapping("/dc") public String dc() &#123; String services = "Services: " + discoveryClient.getServices(); System.out.println(services); return services; &#125;&#125; 最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。123456789@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder( ComputeServiceApplication.class) .web(true).run(args); &#125;&#125; 我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：123spring.application.name=eureka-clientserver.port=2001eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。 启动该工程后，再次访问：http://localhost:1001/。可以如下图内容，我们定义的服务被成功注册了。当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：http://localhost:2001/dc，我们可以得到如下输出返回：1Services: [eureka-client] 其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中区。 Spring Cloud ConsulSpring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性： 服务发现 健康检查 Key/Value存储 多数据中心由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。 以之前实现的基于Eureka的示例（eureka-client）为基础，我们如何将之前实现的服务提供者注册到Consul上呢？方法非常简单，我们只需要在pom.xml中将eureka的依赖修改为如下依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 接下来再修改一下application.properites，将consul需要的配置信息加入即可，比如：（下面配置是默认值）12spring.cloud.consul.host=localhostspring.cloud.consul.port=8500 到此为止，我们将eureka-client转换为基于consul服务治理的服务提供者就完成了。前文我们已经有提到过服务发现的接口DiscoveryClient是Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，我们的程序不需要做任何改变，只需要引入不同的服务治理依赖，并配置相关的配置属性就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。下面可以尝试让consul的服务提供者运行起来。这里可能读者会问，不需要创建类似eureka-server的服务端吗？由于Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。 我们可以用下面的命令启动consul的开发模式：1234567891011121314151617181920212223242526272829303132$consul agent -dev==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running! Version: &apos;v0.7.2&apos; Node name: &apos;Lenovo-zhaiyc&apos; Datacenter: &apos;dc1&apos; Server: true (bootstrap: false) Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400) Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302) Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false Atlas: &lt;disabled&gt;==&gt; Log data will now stream in as it occurs: 2017/06/22 07:50:54 [INFO] raft: Initial configuration (index=1): [&#123;Suffrage:Voter ID:127.0.0.1:8300 Address:127.0.0.1:8300&#125;] 2017/06/22 07:50:54 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &quot;&quot;) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding LAN server Lenovo-zhaiyc (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc.dc1 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding WAN server Lenovo-zhaiyc.dc1 (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:51:01 [ERR] agent: failed to sync remote state: No cluster leader 2017/06/22 07:51:02 [WARN] raft: Heartbeat timeout from &quot;&quot; reached, starting election 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2 2017/06/22 07:51:02 [DEBUG] raft: Votes needed: 1 2017/06/22 07:51:02 [DEBUG] raft: Vote granted from 127.0.0.1:8300 in term 2. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Election won. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state 2017/06/22 07:51:02 [INFO] consul: cluster leadership acquired 2017/06/22 07:51:02 [INFO] consul: New leader elected: Lenovo-zhaiyc 2017/06/22 07:51:02 [DEBUG] consul: reset tombstone GC to index 3 2017/06/22 07:51:02 [INFO] consul: member &apos;Lenovo-zhaiyc&apos; joined, marking health alive 2017/06/22 07:51:02 [INFO] agent: Synced service &apos;consul&apos; 2017/06/22 07:51:02 [DEBUG] agent: Node info in sync consul服务端启动完成之后，我们再将之前改造后的consul服务提供者启动起来。consul与eureka一样，都提供了简单的ui界面来查看服务的注册情况： 更多关于Consul的使用指南，读者可查看官方文档：https://www.consul.io/ 代码示例 码云：点击查看 GitHub：点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client consul的服务提供方：consul-client 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Eureka</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中使用log4j详细配置]]></title>
    <url>%2F2017%2F09%2F26%2Fspring-log4j%2F</url>
    <content type="text"><![CDATA[第一步：导入log4j-1.2.17.jar包。第二步：src同级创建并设置log4j.properties。 log4j.properties的详细配置：123456789101112131415161718192021222324 ### 设置 ###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 更详细的log4j.properties配置 第三步：web.xml中加入配置详细： 1234567891011121314&lt;!-- 设置根目录 --&gt; &lt;!--初始化log4j.properties--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;3000&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; applicationContext.xml就不需要配置了 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.2.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;/beans&gt; 然后日志就可以随着spring的启动而启动了。 如果想把日志文件打印到Tomcat日志文件中：log4j.appender.R.File=${catalina.home}/logs/youLogFile.log 这个方法只能Tomcat使用，其它容器就不行了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mysql存入大量TEXT类型的数据报错]]></title>
    <url>%2F2017%2F09%2F26%2Fmysql-text%2F</url>
    <content type="text"><![CDATA[主要的原因是因为max_sort_length的默认值为1024,=解决办法：该参数是动态参数，任何客户端都可以在Mysql数据库运行时更改该参数的值，例如：1.首先应该查询一下这个参数的默认值为多少1mysql&gt; SELECT @@global.max_sort_length; 2.然后去设置这个值： 1mysql&gt; SET GLOBAL max_sort_length=2048; //2048这个数值由你了 3.然后再查询一下这个参数的默认值：1mysql&gt; SELECT @@global.max_sort_length; 以上问题就解决了]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot Mybatis 整合（完整版）]]></title>
    <url>%2F2017%2F09%2F25%2Fspringboot-mybatis%2F</url>
    <content type="text"><![CDATA[本项目使用的环境：1.开发工具：Intellij IDEA 2017.1.32.jdk：1.7.0_793.maven:3.3.9 步骤：1.创建一个springboot项目： 2.创建项目的文件结构以及jdk的版本 3.选择项目所需要的依赖然后点击finish 5.看一下文件的结构： 6.查看一下pom.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.winter&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-mybatis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 7.配置文件 项目不使用application.properties文件 而使用更加简洁的application.yml文件：将原有的resource文件夹下的application.properties文件删除，创建一个新的application.yml配置文件，文件的内容如下：123456789101112131415161718192021222324252627282930313233343536server: port: 8080spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/depot username: root password: root # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20mybatis: mapper-locations: classpath:mapping/*.xml type-aliases-package: com.winter.model#pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 8.创建数据库：12345678CREATE DATABASE mytest;CREATE TABLE t_user( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(255) NOT NULL , password VARCHAR(255) NOT NULL , phone VARCHAR(255) NOT NULL) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 9.使用mybatis generator 自动生成代码：a.配置pom.xml中generator 插件所对应的配置文件 ${basedir}/src/main/resources/generator/generatorConfig.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="E:\developer\mybatis-generator-core-1.3.2\lib\mysql-connector-java-5.1.25-bin.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1/mytest" userId="root" password="root"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="main.java.com.winter.model" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="main.resources.mapping" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="main.java.com.winter.mapper" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="t_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; b.点击run-Edit Configurations c.添加配置 d.运行 最后生成的文件以及结构： 10.mapper修改 我们还需要修改有点东西，因为生成的类中的路径写了全路径，所以我们要把前面多余的删掉： UserMapper.java12345678910111213141516171819package com.winter.mapper;import com.winter.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer userId); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer userId); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); //这个方式我自己加的 List&lt;User&gt; selectAllUser();&#125; User.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.winter.model;public class User &#123; private Integer userId; private String userName; private String password; private String phone; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone == null ? null : phone.trim(); &#125;&#125; 对于映射文件xml有一个快捷的方式把所有德多余的代码一次删掉： Ctrl+F 进行搜索“main.java.”: 对于sql语句这种黄色的背景，真心是看不下去了（解决方案）： UserMapper.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.winter.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.winter.model.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;!-- 这个方法是我自己加的 --&gt; &lt;select id="selectAllUser" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from t_user &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.winter.model.User" &gt; insert into t_user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.winter.model.User" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.winter.model.User" &gt; update t_user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.winter.model.User" &gt; update t_user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; 11.springboot启动类： 打开类SpringbootMybatisDemoApplication.java，这个是springboot的启动类。我们需要添加点东西： 1234567891011121314package com.winter;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.winter.mapper")//将项目中对应的mapper类的路径加进来就可以了public class SpringbootMybatisDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisDemoApplication.class, args); &#125;&#125; 12.测试： 到这里所有的搭建工作都完成了，接下来就是测试的工作，没使用junit4进行测试： 首先看一下完成之后的文件的结构： 13.controller，service层：UserController.java1234567891011121314151617181920212223242526272829303132package com.winter.Controller;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * Created by Administrator on 2017/8/16. */@Controller@RequestMapping(value = "/user")public class UserController &#123; @Autowired private UserService userService; @ResponseBody @RequestMapping(value = "/add", produces = &#123;"application/json;charset=UTF-8"&#125;) public int addUser(User user)&#123; return userService.addUser(user); &#125; @RequestMapping(value = "/all/&#123;pageNum&#125;/&#123;pageSize&#125;", produces = &#123;"application/json;charset=UTF-8"&#125;) public Object findAllUser(@PathVariable("pageNum") int pageNum, @PathVariable("pageSize") int pageSize)&#123; return userService.findAllUser(pageNum,pageSize); &#125;&#125; UserService.java123456789101112131415package com.winter.service;import com.winter.model.User;import java.util.List;/** * Created by Administrator on 2017/8/16. */public interface UserService &#123; int addUser(User user); List&lt;User&gt; findAllUser(int pageNum, int pageSize);&#125; UserServiceImpl.java123456789101112131415161718192021222324252627282930313233343536373839package com.winter.service.impl;import com.github.pagehelper.PageHelper;import com.winter.mapper.UserMapper;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * Created by Administrator on 2017/8/16. */@Service(value = "userService")public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper;//这里会报错，但是并不会影响 @Override public int addUser(User user) &#123; return userMapper.insertSelective(user); &#125; /* * 这个方法中用到了我们开头配置依赖的分页插件pagehelper * 很简单，只需要在service层传入参数，然后将参数传递给一个插件的一个静态方法即可； * pageNum 开始页数 * pageSize 每页显示的数据条数 * */ @Override public List&lt;User&gt; findAllUser(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 PageHelper.startPage(pageNum, pageSize); return userMapper.selectAllUser(); &#125;&#125; 如果强迫症看不下去那个报错：（解决方法） 14.idea的插件： 可以发http请求的插件： 点击左侧的运行按钮就可以发送请求了；如果返回值正确 说明你已经搭建成功了！！ 源码地址：https://github.com/WinterChenS/springboot-mybatis-demo]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java优雅的输出helloWorld]]></title>
    <url>%2F2017%2F09%2F25%2Fjava-print-helloworld%2F</url>
    <content type="text"><![CDATA[在java中很优雅的输出helloworld，可以试一试1234567891011121314151617public class Test&#123; public static void main(String[] args) &#123; System.out.println(randomString(-229985452) + " " + randomString(-147909649)); &#125; public static String randomString(int seed)&#123; Random rand = new Random(seed); StringBuilder sb = new StringBuilder(); while(true)&#123; int n = rand.nextInt(27); if(n==0) break; sb.append((char)('`'+n)); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
