<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：Hystrix监控面板【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-5-1%2F</url>
    <content type="text"><![CDATA[在上一篇《服务容错保护（hystrix断路器）》的介绍中，我们提到断路器是根据一段时间窗内的请求情况来判断并操作断路器的打开和关闭状态的。而这些请求情况的指标信息都是HystrixCommand和HystrixObservableCommand实例在执行过程中记录的重要度量信息，它们除了Hystrix断路器实现中使用之外，对于系统运维也有非常大的帮助。这些指标信息会以“滚动时间窗”与“桶”结合的方式进行汇总，并在内存中驻留一段时间，以供内部或外部进行查询使用，Hystrix Dashboard就是这些指标内容的消费者之一。 下面我们基于之前的示例来结合Hystrix Dashboard实现Hystrix指标数据的可视化面板，这里我们将用到下之前实现的几个应用，包括： eureka-server：服务注册中心 eureka-client：服务提供者 eureka-consumer-ribbon-hystrix：使用ribbon和hystrix实现的服务消费者 由于 eureka-consumer-ribbon-hystrix 项目中的 /consumer 接口实现使用了 @HystrixCommand 修饰，所以这个接口的调用情况会被Hystrix记录下来，以用来给断路器和Hystrix Dashboard使用。断路器我们在上一篇中已经介绍过了，下面我们来具体说说Hystrix Dashboard的构建。 动手试一试 在Spring Cloud中构建一个Hystrix Dashboard非常简单，只需要下面四步： 创建一个标准的Spring Boot工程，命名为：hystrix-dashboard。编辑pom.xml，具体依赖内容如下： 1234567891011121314151617181920&lt;parent&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-parent&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;relativePath /&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 为应用主类加上@EnableHystrixDashboard，启用Hystrix Dashboard功能。 1234567@EnableHystrixDashboard@SpringCloudApplicationpublic class HystrixDashboardApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(HystrixDashboardApplication.class, args); &#125;&#125; 根据实际情况修改application.properties配置文件，比如：选择一个未被占用的端口等，此步非必须。 12spring.application.name=hystrix-dashboardserver.port=1301 到这里我们已经完成了基本配置，接下来我们可以启动该应用，并访问：http://localhost:1301/hystrix，我们可以看到如下页面： 这是Hystrix Dashboard的监控首页，该页面中并没有具体的监控信息。从页面的文字内容中我们可以知道，Hystrix Dashboard共支持三种不同的监控方式，依次为： 默认的集群监控：通过URL http://turbine-hostname:port/turbine.stream 开启，实现对默认集群的监控。 指定的集群监控：通过URL http://turbine-hostname:port/turbine.stream?cluster=[clusterName]开启，实现对 clusterName 集群的监控。 单体应用的监控：通过URLhttp://hystrix-app:port/hystrix.stream开启，实现对具体某个服务实例的监控。 前两者都对集群的监控，需要整合Turbine才能实现，这部分内容我们将在下一篇中做详细介绍。在本节中，我们主要实现对单个服务实例的监控，所以这里我们先来实现单个服务实例的监控。 既然Hystrix Dashboard监控单实例节点需要通过访问实例的 /hystrix.stream 接口来实现，自然我们需要为服务实例添加这个端点，而添加该功能的步骤也同样简单，只需要下面两步： 在服务实例 pom.xml 中的 dependencies 节点中新增 spring-boot-starter-actuator 监控模块以开启监控相关的端点，并确保已经引入断路器的依赖 spring-cloud-starter-hystrix ： 12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt; 确保在服务实例的主类中已经使用 @EnableCircuitBreaker 或 @EnableHystrix 注解，开启了断路器功能。 到这里已经完成了所有的配置，我们可以在Hystrix Dashboard的首页输入http://localhost:2101/hystrix.stream，已启动对“eureka-consumer-ribbon-hystrix”的监控，点击“Monitor Stream”按钮，此时我们可以看到如下页面： 在对该页面介绍前，我们先看看在首页中我们还没有介绍的两外两个参数： Delay ：该参数用来控制服务器上轮询监控信息的延迟时间，默认为2000毫秒，我们可以通过配置该属性来降低客户端的网络和CPU消耗。 Title ：该参数对应了上图头部标题Hystrix Stream之后的内容，默认会使用具体监控实例的URL，我们可以通过配置该信息来展示更合适的标题。 回到监控页面，我们来详细说说其中各元素的具体含义： 我们可以在监控信息的左上部分找到两个重要的图形信息：一个实心圆和一条曲线。 实心圆：共有两种含义。它通过颜色的变化代表了实例的健康程度，如下图所示，它的健康度从绿色、黄色、橙色、红色递减。该实心圆除了颜色的变化之外，它的大小也会根据实例的请求流量发生变化，流量越大该实心圆就越大。所以通过该实心圆的展示，我们就可以在大量的实例中快速的发现故障实例和高压力实例。 * 曲线：用来记录2分钟内流量的相对变化，我们可以通过它来观察到流量的上升和下降趋势。 其他一些数量指标如下图所示： 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix断路器）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-3%2F</url>
    <content type="text"><![CDATA[前言 在前两篇《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》和《Spring Cloud构建微服务架构：服务容错保护（Hystrix依赖隔离）》中，我们对Hystrix提供的服务降级和依赖隔离有了基本的认识。下面我们将继续说说Hystrix的另外一个重要元件：断路器。 断路器断路器模式源于Martin Fowler的Circuit Breaker一文。“断路器”本身是一种开关装置，用于在电路上保护线路过载，当线路中有电器发生短路时，“断路器”能够及时的切断故障电路，防止发生过载、发热、甚至起火等严重后果。 在分布式架构中，断路器模式的作用也是类似的，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），直接切断原来的主逻辑调用。但是，在Hystrix中的断路器除了切断主逻辑的功能之外，还有更复杂的逻辑，下面我们来看看它更为深层次的处理逻辑。 以在 《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》 一文中实现的服务降级例子为示例，我们来说说断路器的工作原理。当我们把服务提供者eureka-client中加入了模拟的时间延迟之后，在服务消费端的服务降级逻辑因为hystrix命令调用依赖服务超时，触发了降级逻辑，但是即使这样，受限于Hystrix超时时间的问题，我们的调用依然很有可能产生堆积。 这个时候断路器就会发挥作用，那么断路器是在什么情况下开始起作用呢？这里涉及到断路器的三个重要参数：快照时间窗、请求总数下限、错误百分比下限。这个参数的作用分别是： 快照时间窗：断路器确定是否打开需要统计一些请求和错误数据，而统计的时间范围就是快照时间窗，默认为最近的10秒。请求总数下限：在快照时间窗内，必须满足请求总数下限才有资格根据熔断。默认为20，意味着在10秒内，如果该hystrix命令的调用此时不足20次，即时所有的请求都超时或其他原因失败，断路器都不会打开。 错误百分比下限：当请求总数在快照时间窗内超过了下限，比如发生了30次调用，如果在这30次调用中，有16次发生了超时异常，也就是超过50%的错误百分比，在默认设定50%下限情况下，这时候就会将断路器打开。 那么当断路器打开之后会发生什么呢？我们先来说说断路器未打开之前，对于之前那个示例的情况就是每个请求都会在当hystrix超时之后返回fallback，每个请求时间延迟就是近似hystrix的超时时间，如果设置为5秒，那么每个请求就都要延迟5秒才会返回。当熔断器在10秒内发现请求总数超过20，并且错误百分比超过50%，这个时候熔断器打开。打开之后，再有请求调用的时候，将不会调用主逻辑，而是直接调用降级逻辑，这个时候就不会等待5秒之后才返回fallback。通过断路器，实现了自动地发现错误并将降级逻辑切换为主逻辑，减少响应延迟的效果。 在断路器打开之后，处理逻辑并没有结束，我们的降级逻辑已经被成了主逻辑，那么原来的主逻辑要如何恢复呢？对于这一问题，hystrix也为我们实现了自动恢复功能。当断路器打开，对主逻辑进行熔断之后，hystrix会启动一个休眠时间窗，在这个时间窗内，降级逻辑是临时的成为主逻辑，当休眠时间窗到期，断路器将进入半开状态，释放一次请求到原来的主逻辑上，如果此次请求正常返回，那么断路器将继续闭合，主逻辑恢复，如果这次请求依然有问题，断路器继续进入打开状态，休眠时间窗重新计时。 通过上面的一系列机制，hystrix的断路器实现了对依赖资源故障的端口、对降级策略的自动切换以及对主逻辑的自动恢复机制。这使得我们的微服务在依赖外部服务或资源的时候得到了非常好的保护，同时对于一些具备降级逻辑的业务需求可以实现自动化的切换与恢复，相比于设置开关由监控和运维来进行切换的传统实现方式显得更为智能和高效。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix依赖隔离）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-2%2F</url>
    <content type="text"><![CDATA[前言 在上一篇《Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）》中，我们已经体验了如何使用@HystrixCommand来为一个依赖资源定义服务降级逻辑。实现方式非常简单，同时对于降级逻辑还能实现一些更加复杂的级联降级等策略。之前对于使用Hystrix来实现服务容错保护时，除了服务降级之外，我们还提到过线程隔离、断路器等功能。那么在本篇中我们就来具体说说线程隔离。 依赖隔离舱壁模式”对于熟悉Docker的读者一定不陌生，Docker通过“舱壁模式”实现进程的隔离，使得容器与容器之间不会互相影响。而Hystrix则使用该模式实现线程池的隔离，它会为每一个Hystrix命令创建一个独立的线程池，这样就算某个在Hystrix命令包装下的依赖服务出现延迟过高的情况，也只是对该依赖服务的调用产生影响，而不会拖慢其他的服务。 通过对依赖服务的线程池隔离实现，可以带来如下优势： 应用自身得到完全的保护，不会受不可控的依赖服务影响。即便给依赖服务分配的线程池被填满，也不会影响应用自身的额其余部分。 可以有效的降低接入新服务的风险。如果新服务接入后运行不稳定或存在问题，完全不会影响到应用其他的请求。 当依赖的服务从失效恢复正常后，它的线程池会被清理并且能够马上恢复健康的服务，相比之下容器级别的清理恢复速度要慢得多。 当依赖的服务出现配置错误的时候，线程池会快速的反应出此问题（通过失败次数、延迟、超时、拒绝等指标的增加情况）。同时，我们可以在不影响应用功能的情况下通过实时的动态属性刷新（后续会通过Spring Cloud Config与Spring Cloud Bus的联合使用来介绍）来处理它。 当依赖的服务因实现机制调整等原因造成其性能出现很大变化的时候，此时线程池的监控指标信息会反映出这样的变化。同时，我们也可以通过实时动态刷新自身应用对依赖服务的阈值进行调整以适应依赖方的改变。 除了上面通过线程池隔离服务发挥的优点之外，每个专有线程池都提供了内置的并发实现，可以利用它为同步的依赖服务构建异步的访问。 总之，通过对依赖服务实现线程池隔离，让我们的应用更加健壮，不会因为个别依赖服务出现问题而引起非相关服务的异常。同时，也使得我们的应用变得更加灵活，可以在不停止服务的情况下，配合动态配置刷新实现性能配置上的调整。 虽然线程池隔离的方案带了如此多的好处，但是很多使用者可能会担心为每一个依赖服务都分配一个线程池是否会过多地增加系统的负载和开销。对于这一点，使用者不用过于担心，因为这些顾虑也是大部分工程师们会考虑到的，Netflix在设计Hystrix的时候，认为线程池上的开销相对于隔离所带来的好处是无法比拟的。同时，Netflix也针对线程池的开销做了相关的测试，以证明和打消Hystrix实现对性能影响的顾虑。 下图是Netflix Hystrix官方提供的一个Hystrix命令的性能监控，该命令以每秒60个请求的速度（QPS）向一个单服务实例进行访问，该服务实例每秒运行的线程数峰值为350个。 比较情况 未使用线程池隔离 使用了线程池隔离 耗时差距 中位数 2ms 2ms 2ms 90百分位 5ms 8ms 3ms 99百分位 28ms 37ms 9ms 在99%的情况下，使用线程池隔离的延迟有9ms，对于大多数需求来说这样的消耗是微乎其微的，更何况为系统在稳定性和灵活性上所带来的巨大提升。虽然对于大部分的请求我们可以忽略线程池的额外开销，而对于小部分延迟本身就非常小的请求（可能只需要1ms），那么9ms的延迟开销还是非常昂贵的。实际上Hystrix也为此设计了另外的一个解决方案：信号量。 Hystrix中除了使用线程池之外，还可以使用信号量来控制单个依赖服务的并发度，信号量的开销要远比线程池的开销小得多，但是它不能设置超时和实现异步访问。所以，只有在依赖服务是足够可靠的情况下才使用信号量。在HystrixCommand和HystrixObservableCommand中2处支持信号量的使用： 命令执行：如果隔离策略参数execution.isolation.strategy设置为SEMAPHORE，Hystrix会使用信号量替代线程池来控制依赖服务的并发控制。 降级逻辑：当Hystrix尝试降级逻辑时候，它会在调用线程中使用信号量。 信号量的默认值为10，我们也可以通过动态刷新配置的方式来控制并发线程的数量。对于信号量大小的估算方法与线程池并发度的估算类似。仅访问内存数据的请求一般耗时在1ms以内，性能可以达到5000rps，这样级别的请求我们可以将信号量设置为1或者2，我们可以按此标准并根据实际请求耗时来设置信号量。 如何使用说了那么多依赖隔离的好处，那么我们如何使用Hystrix来实现依赖隔离呢？其实，我们在上一篇定义服务降级的时候，已经自动的实现了依赖隔离。 在上一篇的示例中，我们使用了@HystrixCommand来将某个函数包装成了Hystrix命令，这里除了定义服务降级之外，Hystrix框架就会自动的为这个函数实现调用的隔离。所以，依赖隔离、服务降级在使用时候都是一体化实现的，这样利用Hystrix来实现服务容错保护在编程模型上就非常方便的，并且考虑更为全面。除了依赖隔离、服务降级之外，还有一个重要元素：断路器。我们将在下一篇做详细的介绍，这三个重要利器构成了Hystrix实现服务容错保护的强力组合拳。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务容错保护（Hystrix服务降级）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-4-1%2F</url>
    <content type="text"><![CDATA[前言在微服务架构中，我们将系统拆分成了一个个的服务单元，各单元应用间通过服务注册与订阅的方式互相依赖。由于每个单元都在不同的进程中运行，依赖通过远程调用的方式执行，这样就有可能因为网络原因或是依赖服务自身问题出现调用故障或延迟，而这些问题会直接导致调用方的对外服务也出现延迟，若此时调用方的请求不断增加，最后就会出现因等待出现故障的依赖方响应而形成任务积压，线程资源无法释放，最终导致自身服务的瘫痪，进一步甚至出现故障的蔓延最终导致整个系统的瘫痪。如果这样的架构存在如此严重的隐患，那么相较传统架构就更加的不稳定。为了解决这样的问题，因此产生了断路器等一系列的服务保护机制。 针对上述问题，在Spring Cloud Hystrix中实现了线程隔离、断路器等一系列的服务保护功能。它也是基于Netflix的开源框架 Hystrix实现的，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备了服务降级、服务熔断、线程隔离、请求缓存、请求合并以及服务监控等强大功能。 接下来，我们就从一个简单示例开始对Spring Cloud Hystrix的学习与使用。 动手试一试在开始使用Spring Cloud Hystrix实现断路器之前，我们先拿之前实现的一些内容作为基础，其中包括： eureka-server 工程：服务注册中心，端口：1001 eureka-client 工程：服务提供者，两个实例启动端口分别为2001 下面我们可以复制一下之前实现的一个服务消费者： eureka-consumer-ribbon ，命名为 eureka-consumer-ribbon-hystrix 。下面我们开始对其进行改在： 第一步： pom.xml 的dependencies节点中引入 spring-cloud-starter-hystrix 依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 第二步：在应用主类中使用@EnableCircuitBreaker或@EnableHystrix注解开启Hystrix的使用： 12345678910111213@EnableCircuitBreaker@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 注意：这里我们还可以使用Spring Cloud应用中的@SpringCloudApplication注解来修饰应用主类，该注解的具体定义如下所示。我们可以看到该注解中包含了上我们所引用的三个注解，这也意味着一个Spring Cloud标准应用应包含服务发现以及断路器。 123456789@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootApplication@EnableDiscoveryClient@EnableCircuitBreakerpublic @interface SpringCloudApplication &#123;&#125; 第三步：改造服务消费方式，新增 ConsumerService 类，然后将在 Controller 中的逻辑迁移过去。最后，在为具体执行逻辑的函数上增加 @HystrixCommand 注解来指定服务降级方法，比如： 1234567891011121314151617181920@RestControllerpublic class DcController &#123; @Autowired ConsumerService consumerService; @GetMapping("/consumer") public String dc() &#123; return consumerService.consumer(); &#125; class ConsumerService &#123; @Autowired RestTemplate restTemplate; @HystrixCommand(fallbackMethod = "fallback") public String consumer() &#123; return restTemplate.getForObject("http://eureka-client/dc", String.class); &#125; public String fallback() &#123; return "fallback"; &#125; &#125;&#125; 下面我们来验证一下上面Hystrix带来的一些基础功能。我们先把涉及的服务都启动起来，然后访问 localhost:2101/consumer ，此时可以获取正常的返回，比如： Services: [eureka-consumer-ribbon-hystrix, eureka-client] 。 为了触发服务降级逻辑，我们可以将服务提供者 eureka-client 的逻辑加一些延迟，比如： 1234567@GetMapping("/dc")public String dc() throws InterruptedException &#123; Thread.sleep(5000L); String services = "Services: " + discoveryClient.getServices(); System.out.println(services); return services;&#125; 重启 eureka-client 之后，再尝试访问 localhost:2101/consumer ，此时我们将获得的返回结果为： fallback 。我们从 eureka-client 的控制台中，可以看到服务提供方输出了原本要返回的结果，但是由于返回前延迟了5秒，而服务消费方触发了服务请求超时异常，服务消费者就通过 HystrixCommand 注解中指定的降级逻辑进行执行，因此该请求的结果返回了 fallback 。这样的机制，对自身服务起到了基础的保护，同时还为异常情况提供了自动的服务降级切换机制。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-ribbon-hystrix 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：分布式配置中心【Dalston版】]]></title>
    <url>%2F2017%2F10%2F21%2Fspring-cloud-starter-dalston-3%2F</url>
    <content type="text"><![CDATA[Spring Cloud Config是Spring Cloud团队创建的一个全新项目，用来为分布式系统中的基础设施和微服务应用提供集中化的外部配置支持，它分为服务端与客户端两个部分。其中服务端也称为分布式配置中心，它是一个独立的微服务应用，用来连接配置仓库并为客户端提供获取配置信息、加密/解密信息等访问接口；而客户端则是微服务架构中的各个微服务应用或基础设施，它们通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。Spring Cloud Config实现了对服务端和客户端中环境变量和属性配置的抽象映射，所以它除了适用于Spring构建的应用程序之外，也可以在任何其他语言运行的应用程序中使用。由于Spring Cloud Config实现的配置中心默认采用Git来存储配置信息，所以使用Spring Cloud Config构建的配置服务器，天然就支持对微服务应用配置信息的版本管理，并且可以通过Git客户端工具来方便的管理和访问配置内容。当然它也提供了对其他存储方式的支持，比如：SVN仓库、本地化文件系统。 在本文中，我们将学习如何构建一个基于Git存储的分布式配置中心，并对客户端进行改造，并让其能够从配置中心获取配置信息并绑定到代码中的整个过程。 准备配置仓库 准备一个git仓库，可以在码云或Github上创建都可以。比如本文准备的仓库示例：https://gitee.com/winter_chen/config-repo 假设我们读取配置中心的应用名为 config-client，那么我们可以在git仓库中该项目的默认配置文件 config-client.yml： 12info: profile: default 为了演示加载不同环境的配置，我们可以在git仓库中再创建一个针对dev环境的配置文件 config-client-dev.yml： 12info: profile: dev 构建配置中心通过Spring Cloud Config来构建一个分布式配置中心非常简单，只需要三步： 创建一个基础的Spring Boot工程，命名为： config-server-git ，并在 pom.xml 中引入下面的依赖（省略了parent和dependencyManagement部分）： 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring Boot的程序主类，并添加 @EnableConfigServer 注解，开启Spring Cloud Config的服务端功能。 1234567@EnableConfigServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 在 application.yml 中添加配置服务的基本信息以及Git仓库的相关信息，例如： 12345678910spring application: name: config-server cloud: config: server: git: uri: http://git.oschina.net/didispace/config-repo-demo/server: port: 1201 到这里，使用一个通过Spring Cloud Config实现，并使用Git管理配置内容的分布式配置中心就已经完成了。我们可以将该应用先启动起来，确保没有错误产生，然后再尝试下面的内容。 如果我们的Git仓库需要权限访问，那么可以通过配置下面的两个属性来实现；spring.cloud.config.server.git.username：访问Git仓库的用户名spring.cloud.config.server.git.password：访问Git仓库的用户密码 完成了这些准备工作之后，我们就可以通过浏览器、POSTMAN或CURL等工具直接来访问到我们的配置内容了。访问配置信息的URL与配置文件的映射关系如下： /{application}/{profile}[/{label}] /{application}-{profile}.yml /{label}/{application}-{profile}.yml /{application}-{profile}.properties /{label}/{application}-{profile}.properties 上面的url会映射{application}-{profile}.properties对应的配置文件，其中 {label} 对应Git上不同的分支，默认为master。我们可以尝试构造不同的url来访问不同的配置内容，比如，要访问master分支，config-client应用的dev环境，就可以访问这个url： http://localhost:1201/config-client/dev/master ，并获得如下返回： 1234567891011121314151617181920212223&#123; "name": "config-client", "profiles": [ "dev" ], "label": "master", "version": null, "state": null, "propertySources": [ &#123; "name": "http://git.oschina.net/didispace/config-repo-demo/config-client-dev.yml", "source": &#123; "info.profile": "dev" &#125; &#125;, &#123; "name": "http://git.oschina.net/didispace/config-repo-demo/config-client.yml", "source": &#123; "info.profile": "default" &#125; &#125; ]&#125; 我们可以看到该Json中返回了应用名：config-client，环境名：dev，分支名：master，以及default环境和dev环境的配置内容。 构建客户端在完成了上述验证之后，确定配置服务中心已经正常运作，下面我们尝试如何在微服务应用中获取上述的配置信息。 创建一个Spring Boot应用，命名为config-client，并在pom.xml中引入下述依赖： 12345678910&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建Spring Boot的应用主类，具体如下： 123456@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建 bootstrap.yml 配置，来指定获取配置文件的 config-server-git 位置，例如： 12345678910spring: application: name: config-client cloud: config: uri: http://localhost:1201/ profile: default label: masterserver: port: 2001 上述配置参数与Git中存储的配置文件中各个部分的对应关系如下： spring.application.name：对应配置文件规则中的{application}部分 spring.cloud.config.profile：对应配置文件规则中的{profile}部分 spring.cloud.config.label：对应配置文件规则中的{label}部分 spring.cloud.config.uri：配置中心config-server的地址 这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，这样config-server中的配置信息才能被正确加载。 在完成了上面你的代码编写之后，读者可以将config-server-git、config-client都启动起来，然后访问http://localhost:2001/info ，我们可以看到该端点将会返回从git仓库中获取的配置信息： 123&#123; "profile": "default"&#125; 另外，我们也可以修改config-client的profile为dev来观察加载配置的变化。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： 基于Git仓库的配置中心：config-server-git 使用配置中心的客户端：config-client 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java导出Excel文档（poi），并上传到腾讯云对象存储服务器]]></title>
    <url>%2F2017%2F10%2F21%2Fjava-make-excel-poi-to-upload-cloud%2F</url>
    <content type="text"><![CDATA[需求后台生成周报月报季报年报Excel，将文件下载链接推送给对应客户 开发思路：1.根据选定日期生成周报，月报，季报，年报数据2.将这些数据报告生成Excel表格3.把生成的文件上传到腾讯云对象存储服务器4.将服务器返回的url存储到数据库 工具poi-3.14-20160307.jar(点击可下载) 数据获取数据部分省略了 代码主方法1234567891011121314151617public boolean addReportExcelToCloud(ReportResult rr) &#123; OutputStream out = new ByteArrayOutputStream(); ExcelProjectUtils eu = new ExcelProjectUtils(); eu.exportExcel(rr, out); //&lt;1&gt; ConvertUtil cu = new ConvertUtil(); try &#123; ByteArrayInputStream byteInput = cu.parse(out); String rs = PicUploadToYun.uploadExcel(SysContent.getFileRename("案场数据报.xls"), byteInput); //&lt;2&gt; addReportExcelToDB(rr, rs); //&lt;3&gt; return true; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 将数据生成二进制Excel文件 (方法详细见下面代码) 将生成的二进制文件上传到腾讯云对象存储服务器 (方法详细见下面代码) 将服务器返回的url存储到数据库 (方法详细见下面代码) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392/** * 周报年报生成excel * * @param report * @param out */ public void exportExcel(ReportResult report, OutputStream out) &#123; // 判断传入的时间间隔 String dateStr = ""; String reportName = ""; List&lt;String&gt; dateCount = DateUtil.getTwoDateEveryDay(report.getStartTime(), report.getEndTime()); if (dateCount.size() &lt;= 7) &#123; dateStr += "本周"; reportName += "案场周报"; &#125; else if (dateCount.size() &gt;= 28 &amp;&amp; dateCount.size() &lt;= 31) &#123; dateStr += "本月"; reportName += "案场月报"; &#125; else if (dateCount.size() &gt;= 85 &amp;&amp; dateCount.size() &lt;= 100) &#123; dateStr += "本季度"; reportName += "案场季报"; &#125; else if (dateCount.size() &gt;= 180 &amp;&amp; dateCount.size() &lt;= 185) &#123; dateStr += "本半年度"; reportName += "案场半年报"; &#125; else if (dateCount.size() &gt;= 360 &amp;&amp; dateCount.size() &lt;= 367) &#123; dateStr += "本年度"; reportName += "案场年报"; &#125; else &#123; dateStr += "时间段内"; reportName += "案场阶段报"; &#125; report.setReportName(reportName); // 声明一个工作薄 HSSFWorkbook workbook = new HSSFWorkbook(); // 生成一个表格 HSSFSheet sheet = workbook.createSheet(report.getReportName() + report.getStartTime() + " - " + report.getEndTime()); // 设置表格默认列宽度为100个字节 sheet.setDefaultColumnWidth((short) 100); /** ----------样式一：标题 ------------ **/ HSSFCellStyle style = workbook.createCellStyle(); // 设置这些样式 style.setBorderLeft(HSSFCellStyle.BORDER_THIN); style.setBorderRight(HSSFCellStyle.BORDER_THIN); //style.setBorderTop(HSSFCellStyle.BORDER_THIN); style.setAlignment(HSSFCellStyle.ALIGN_CENTER); // 生成一个字体 HSSFFont font = workbook.createFont(); font.setFontName("宋体"); //font.setColor(HSSFColor.VIOLET.index); font.setFontHeightInPoints((short) 14); font.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 把字体应用到当前的样式 style.setFont(font); /***---------样式二：小标题---------***/ HSSFCellStyle style2 = workbook.createCellStyle(); style2.setBorderLeft(HSSFCellStyle.BORDER_THIN); style2.setBorderRight(HSSFCellStyle.BORDER_THIN); //style2.setBorderTop(HSSFCellStyle.BORDER_THIN); style2.setAlignment(HSSFCellStyle.ALIGN_LEFT); //style2.setVerticalAlignment(HSSFCellStyle.VERTICAL_CENTER); // 生成另一个字体 HSSFFont font2 = workbook.createFont(); //font2.setBoldweight(HSSFFont.BOLDWEIGHT_NORMAL); font2.setFontName("宋体"); font2.setFontHeightInPoints((short) 11); font2.setBoldweight(HSSFFont.BOLDWEIGHT_BOLD); // 把字体应用到当前的样式 style2.setFont(font2); /*** 样式三：右侧日期 ***/ HSSFCellStyle style3 = workbook.createCellStyle(); //样式 style3.setBorderLeft(HSSFCellStyle.BORDER_THIN); style3.setBorderRight(HSSFCellStyle.BORDER_THIN); style3.setAlignment(HSSFCellStyle.ALIGN_RIGHT); style3.setBorderBottom(HSSFCellStyle.BORDER_THIN); //字体 HSSFFont font3 = workbook.createFont(); font3.setFontName("宋体"); font3.setFontHeightInPoints((short) 11); style3.setFont(font3); /** 样式四：主内容 ***/ HSSFCellStyle style4 = workbook.createCellStyle(); //样式 style4.setBorderLeft(HSSFCellStyle.BORDER_THIN); style4.setBorderRight(HSSFCellStyle.BORDER_THIN); style4.setAlignment(HSSFCellStyle.ALIGN_LEFT); //字体 HSSFFont font4 = workbook.createFont(); font4.setFontName("宋体"); font4.setFontHeightInPoints((short) 11); style4.setFont(font4); /** 样式五：底侧空内容 ***/ HSSFCellStyle style5 = workbook.createCellStyle(); //样式 style5.setBorderLeft(HSSFCellStyle.BORDER_THIN); style5.setBorderRight(HSSFCellStyle.BORDER_THIN); style5.setAlignment(HSSFCellStyle.ALIGN_LEFT); style5.setBorderBottom(HSSFCellStyle.BORDER_THIN); //字体 HSSFFont font5 = workbook.createFont(); font5.setFontName("宋体"); font5.setFontHeightInPoints((short) 11); style5.setFont(font5); // 声明一个画图的顶级管理器 HSSFPatriarch patriarch = sheet.createDrawingPatriarch(); // 定义注释的大小和位置,详见文档 HSSFComment comment = patriarch.createComment(new HSSFClientAnchor(0, 0, 0, 0, (short) 4, 2, (short) 6, 5)); // 设置注释内容 comment.setString(new HSSFRichTextString("数据报")); // 设置注释作者，当鼠标移动到单元格上是可以在状态栏中看到该内容. comment.setAuthor("saas"); // 产生表格标题行 -- 项目名称 HSSFRow row = sheet.createRow(0); createCellAndRow(style4, report.getProjectName(), row); // 产生表格标题行 -- 周报名称 row = sheet.createRow(1); createCellAndRow(style, report.getReportName(), row); // 产生表格标题行 -- 起始时间-终止时间 row = sheet.createRow(2); String startTime = DateUtil.format(DateUtil.parse(report.getStartTime(), DateUtil.PATTERN_CLASSICAL_SIMPLE), DateUtil.PATTERN_CLASSICAL_SIMPLE_YMD); String endTime = DateUtil.format(DateUtil.parse(report.getEndTime(), DateUtil.PATTERN_CLASSICAL_SIMPLE), DateUtil.PATTERN_CLASSICAL_SIMPLE_YMD); String date = "日期：" + startTime + " - " + endTime; createCellAndRow(style3, date, row); // 接访情况标题 row = sheet.createRow(3); createCellAndRow(style2, "·接访情况", row); // 接访客户组数 row = sheet.createRow(4); Integer visitCount = report.getVisitCount(); String visitNum = "1、" + dateStr + "共计接访客户" + visitCount + "组，来访量"; if (visitCount &lt; 40) &#123; visitNum += "较少，有待提升"; &#125; else if (visitCount &gt;= 41 &amp;&amp; visitCount &lt;= 99) &#123; visitNum += "尚可，还有提高空间"; &#125; else if (visitCount &gt;= 100 &amp;&amp; visitCount &lt;= 139) &#123; visitNum += "很多"; &#125; else if (visitCount &gt; 140) &#123; visitNum += "火爆"; &#125; createCellAndRow(style4, visitNum, row); // 有效接访率 row = sheet.createRow(5); Double visitRate = new Double(report.getValidVisitRate()); String visitRateStr = "2、有效接访率为" + visitRate + "%，接访成效"; if (visitRate &lt; 50) &#123; visitRateStr += "较低，有待提升"; &#125; else if (visitRate &gt;= 50 &amp;&amp; visitRate &lt;= 65) &#123; visitRateStr += "尚可，还有提高空间"; &#125; else if (visitRate &gt;= 65 &amp;&amp; visitRate &lt;= 80) &#123; visitRateStr += "很高"; &#125; else if (visitRate &gt; 80) &#123; visitRateStr += "极高"; &#125; createCellAndRow(style4, visitRateStr, row); // 首访有效率 row = sheet.createRow(6); Double newVisitRate = new Double(report.getValidNewCuVisitRate()); String newVisitStr = "3、首访有效率为" + newVisitRate + "%，来访转储客的概率"; if (newVisitRate &lt; 40) &#123; newVisitStr += "较差，有待提升"; &#125; else if (newVisitRate &gt;= 40 &amp;&amp; newVisitRate &lt;= 60) &#123; newVisitStr += "尚可，还有提高空间"; &#125; else if (newVisitRate &gt;= 60 &amp;&amp; newVisitRate &lt;= 75) &#123; newVisitStr += "很高"; &#125; else if (newVisitRate &gt; 75) &#123; newVisitStr += "极高"; &#125; createCellAndRow(style4, newVisitStr, row); // 老客户接访占比 row = sheet.createRow(7); Double oldVisitRate = new Double(report.getOldCuVisitRate()); String oldVisitStr = "4、老客户接访比为" + oldVisitRate + "%，老客户接访的占比"; if (oldVisitRate &lt; 20) &#123; oldVisitStr += "较低"; &#125; else if (oldVisitRate &gt;= 20 &amp;&amp; oldVisitRate &lt;= 40) &#123; oldVisitStr += "尚可"; &#125; else if (oldVisitRate &gt;= 40 &amp;&amp; oldVisitRate &lt;= 60) &#123; oldVisitStr += "很高"; &#125; else if (oldVisitRate &gt; 60) &#123; oldVisitStr += "极高"; &#125; createCellAndRow(style4, oldVisitStr, row); //空行 row = sheet.createRow(8); createCellAndRow(style4, "", row); // 储客情况 row = sheet.createRow(9); createCellAndRow(style2, "·储客情况", row); // 新增储客 row = sheet.createRow(10); Integer newCuCount = report.getNewCuCount(); String newCuStr = "1、" + dateStr + "新增储客" + newCuCount + "组，新增量"; if (newCuCount &lt; 30) &#123; newCuStr += "较少，有待提升"; &#125; else if (newCuCount &gt;= 31 &amp;&amp; newCuCount &lt;= 60) &#123; newCuStr += "尚可，还有提高空间"; &#125; else if (newCuCount &gt;= 61 &amp;&amp; newCuCount &lt;= 79) &#123; newCuStr += "很多"; &#125; else if (newCuCount &gt; 80) &#123; newCuStr += "爆满"; &#125; createCellAndRow(style4, newCuStr, row); // 累计老客户 row = sheet.createRow(11); Integer oldCuCount = report.getTotalOldCuCount(); Integer totalCuCount = report.getTotalCuCount(); Double oldCuRate = new Double(SysContent.getTwoNumberForValue(oldCuCount, totalCuCount)); String oldCuStr = "2、累计老客户总量为" + oldCuCount + "组，老客户占比为" + oldCuRate + "%，显示老客户关注度"; if (oldCuRate &lt; 15) &#123; oldCuStr += "较低，有待提升"; &#125; else if (oldCuRate &gt;= 15 &amp;&amp; oldCuRate &lt;= 25) &#123; oldCuStr += "尚可，还有提高空间"; &#125; else if (oldCuRate &gt;= 25 &amp;&amp; oldCuRate &lt;= 40) &#123; oldCuStr += "很高"; &#125; else if (oldCuRate &gt; 40) &#123; oldCuStr += "极高"; &#125; createCellAndRow(style4, oldCuStr, row); // 累计总储客 row = sheet.createRow(12); String totalOldCuStr = "3、累计总储客" + totalCuCount + "组"; createCellAndRow(style4, totalOldCuStr, row); // 成交情况(周报没有，其他有) if (report.getSubscribeHouseCount() != null) &#123; //空行 row = sheet.createRow(13); createCellAndRow(style4, "", row); row = sheet.createRow(14); createCellAndRow(style2, "·成交情况", row); // 新增认购套数 row = sheet.createRow(15); Integer subscribeHouseCount = report.getSubscribeHouseCount(); Double subscribeHouseRate = new Double(report.getSubscribeHouseRate()); String subscribeHouseStr = "1、" + dateStr + "新增认购套数" + subscribeHouseCount + "套，较" + dateStr + "同期"; if (subscribeHouseRate &lt; 0) &#123; subscribeHouseStr += "减少"; &#125; else &#123; subscribeHouseStr += "增长"; &#125; subscribeHouseStr += Math.abs(subscribeHouseRate) + "%"; createCellAndRow(style4, subscribeHouseStr, row); // 新增认购金额 row = sheet.createRow(16); Long subscribeMoney = report.getSubscribeMoney(); Double subscribeMoneyRate = new Double(report.getSubscribeMoneyRate()); String subscribeMoneyStr = " 新增认购金额" + subscribeMoney + "万元，较" + dateStr + "同期"; if (subscribeHouseRate &lt; 0) &#123; subscribeMoneyStr += "减少"; &#125; else &#123; subscribeMoneyStr += "增长"; &#125; subscribeMoneyStr += Math.abs(subscribeMoneyRate) + "%"; createCellAndRow(style4, subscribeMoneyStr, row); // 新增签约套数 row = sheet.createRow(17); Integer signCount = report.getSignCount(); Double signRate = new Double(report.getSignRate()); String signStr = "2、新增签约套数" + signCount + "套,较" + dateStr + "同期"; if (signRate &lt; 0) &#123; signStr += "减少"; &#125; else &#123; signStr += "增长"; &#125; signStr += Math.abs(signRate) + "%"; createCellAndRow(style4, signStr, row); // 新增签约金额 row = sheet.createRow(18); Long signHouseMoney = report.getSignHouseMoney(); Double signHouseMoneyRate = new Double(report.getSignHouseMoneyRate()); String signHouseMoneyStr = " 新增签约金额" + signHouseMoney + "万元，较" + dateStr + "同期"; if (signHouseMoneyRate &lt; 0) &#123; signHouseMoneyStr += "减少"; &#125; else &#123; signHouseMoneyStr += "增长"; &#125; signHouseMoneyStr += Math.abs(signHouseMoneyRate) + "%"; createCellAndRow(style4, signHouseMoneyStr, row); // 新接访签约率 row = sheet.createRow(19); Double newCustomerSignedRate = new Double(report.getNewCustomerSignedRate()); String newCustomerSignedStr = "3、" + dateStr + "新客户接访签约率" + newCustomerSignedRate + "%，接访签约概率"; if (newCustomerSignedRate &lt; 4) &#123; newCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (newCustomerSignedRate &gt;= 4 &amp;&amp; newCustomerSignedRate &lt;= 6) &#123; newCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (newCustomerSignedRate &gt;= 6 &amp;&amp; newCustomerSignedRate &lt;= 7) &#123; newCustomerSignedStr += "很高"; &#125; else if (newCustomerSignedRate &gt; 7) &#123; newCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, newCustomerSignedStr, row); // 储客签约率 row = sheet.createRow(20); Double momeryCustomerSignedRate = new Double(report.getMomeryCustomerSignedRate()); String momeryCustomerSignedStr = "4、储客签约率" + momeryCustomerSignedRate + "%，储备客户签约概率"; if (momeryCustomerSignedRate &lt; 7) &#123; momeryCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (momeryCustomerSignedRate &gt;= 7 &amp;&amp; momeryCustomerSignedRate &lt;= 12) &#123; momeryCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (momeryCustomerSignedRate &gt;= 12 &amp;&amp; momeryCustomerSignedRate &lt;= 15) &#123; momeryCustomerSignedStr += "很高"; &#125; else if (momeryCustomerSignedRate &gt; 15) &#123; momeryCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, momeryCustomerSignedStr, row); // 老客户签约率 row = sheet.createRow(21); Double oldCustomerSignedRate = new Double(report.getOldCustomerSignedRate()); String oldCustomerSignedStr = "5、老客户签约率为23.2%，高意向客户签约概率"; if (oldCustomerSignedRate &lt; 25) &#123; oldCustomerSignedStr += "较低，与理想值差距大"; &#125; else if (oldCustomerSignedRate &gt;= 25 &amp;&amp; oldCustomerSignedRate &lt;= 35) &#123; oldCustomerSignedStr += "尚可，还有提高空间"; &#125; else if (oldCustomerSignedRate &gt;= 35 &amp;&amp; oldCustomerSignedRate &lt;= 50) &#123; oldCustomerSignedStr += "很高"; &#125; else if (oldCustomerSignedRate &gt; 50) &#123; oldCustomerSignedStr += "非常高"; &#125; createCellAndRow(style4, oldCustomerSignedStr, row); // 认购客户签约率 row = sheet.createRow(22); Double contratCuSignedRate = new Double(report.getContratCuSignedRate()); String contratCuSignedStr = "6、认购客户签约率为92%，已认购客户签约率"; if (contratCuSignedRate &lt; 95) &#123; contratCuSignedStr += "不高，较多退订或拒签"; &#125; else if (contratCuSignedRate &gt;= 95 &amp;&amp; contratCuSignedRate &lt;= 97) &#123; contratCuSignedStr += "尚可，一定数量退订或拒签"; &#125; else if (contratCuSignedRate &gt;= 97 &amp;&amp; contratCuSignedRate &lt;= 99) &#123; contratCuSignedStr += "很高"; &#125; else if (contratCuSignedRate &gt; 99) &#123; contratCuSignedStr += "非常高"; &#125; createCellAndRow(style4, contratCuSignedStr, row); //空行 row = sheet.createRow(23); createCellAndRow(style4, "", row); //底侧 row = sheet.createRow(24); createCellAndRow(style5, "", row); &#125;else&#123; row = sheet.createRow(13); createCellAndRow(style5, "", row); &#125; try &#123; workbook.write(out); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void createCellAndRow(HSSFCellStyle style, String text, HSSFRow row) &#123; HSSFCell cell = row.createCell(0); cell.setCellStyle(style); HSSFRichTextString rs = new HSSFRichTextString(text); cell.setCellValue(rs); &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 上传Excel * @param fileNewName * @param uploadFile * @return */ public static String uploadExcel(String fileNewName,ByteArrayInputStream uploadFile)&#123; // 设置用户属性, 包括appid, secretId和SecretKey // 这些属性可以通过cos控制台获取(https://console.qcloud.com/cos) String version = PropertiesUtil.getValue("version"); long appId = "你的appId"; String secretId = "你的secretId "; String secretKey = "你的secretKey "; // 设置要操作的bucket String bucketName = "root"; // 初始化客户端配置 ClientConfig clientConfig = new ClientConfig(); // 设置bucket所在的区域，比如广州(gz), 天津(tj) clientConfig.setRegion("sh"); // 初始化秘钥信息 Credentials cred = new Credentials(appId, secretId, secretKey); // 初始化cosClient COSClient cosClient = new COSClient(clientConfig, cred); // 文件操作 // // 1. 上传文件(默认不覆盖) // 将本地的local_file_1.txt上传到bucket下的根分区下,并命名为sample_file.txt // 默认不覆盖, 如果cos上已有文件, 则返回错误 String cosFilePath = "/report/" + fileNewName; byte[] localFilePath1 = null; try &#123; localFilePath1 = ConvertUtil.toByteArray(uploadFile); &#125; catch (IOException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; UploadFileRequest uploadFileRequest = new UploadFileRequest(bucketName, cosFilePath, localFilePath1); uploadFileRequest.setEnableShaDigest(false); String uploadFileRet = cosClient.uploadFile(uploadFileRequest); System.out.println("upload file ret:" + uploadFileRet); //获取保存路径 ObjectMapper om = new ObjectMapper(); HashMap map = new HashMap&lt;&gt;(); try &#123; map = om.readValue(uploadFileRet, HashMap.class); &#125; catch (JsonParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (JsonMappingException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; HashMap&lt;String, String&gt; value = (HashMap&lt;String, String&gt;) map.get("data"); return value.get("source_url"); &#125; 123456789101112131415161718192021222324252627282930313233343536public boolean addReportExcelToDB(ReportResult rr, String url) &#123; if(StringUtils.isEmpty(url))&#123; return false; &#125; if(rr == null)&#123; return false; &#125; ProjectReportRecord prr = new ProjectReportRecord(); prr.setCreateTime(DateUtil.format(new Date())); prr.setProjectId(rr.getProjectId()); prr.setProjectName(rr.getProjectName()); prr.setStartTime(rr.getStartTime()); prr.setEndTime(rr.getEndTime()); prr.setUrl(url); String report = ""; if("案场周报".equals(rr.getReportName()))&#123; report = "week"; &#125;else if("案场月报".equals(rr.getReportName()))&#123; report = "month"; &#125;else if("案场季报".equals(rr.getReportName()))&#123; report = "quarter"; &#125;else if("案场半年报".equals(rr.getReportName()))&#123; report = "half"; &#125;else if("案场年报".equals(rr.getReportName()))&#123; report = "year"; &#125;else&#123; report = "other"; &#125; prr.setReportName(report); baseDao.save(prr); return true; &#125; 生成的文件示例周报或者其他报告都是后台自动根据时间进行判断的 周报 季报 以上]]></content>
      <categories>
        <category>JavaUtils</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>poi</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Feign）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-3%2F</url>
    <content type="text"><![CDATA[通过前两篇《Spring Cloud构建微服务架构：服务消费（基础）》和《Spring Cloud构建微服务架构：服务消费（Ribbon）》，我们已经学会了在Spring Cloud中基本的服务调用方式。本文我们将继续介绍Spring Cloud中的另外一个服务消费的工具：Spring Cloud Feign。 Spring Cloud Feign Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。 下面，我们通过一个例子来展现Feign如何方便的声明对eureka-client服务的定义和调用。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-feign。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能： 12345678@EnableFeignClients@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子： 12345@FeignClient("eureka-client")public interface DcClient &#123; @GetMapping("/dc") String consumer();&#125; 修改Controller。通过定义的feign客户端来调用服务提供方的接口： 123456789@RestControllerpublic class DcController &#123; @Autowired DcClient dcClient; @GetMapping("/consumer") public String dc() &#123; return dcClient.consumer(); &#125;&#125; 通过Spring Cloud Feign来实现服务调用的方式更加简单了，通过@FeignClient定义的接口来统一的生命我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可。由于Feign是基于Ribbon实现的，所以它自带了客户端负载均衡功能，也可以通过Ribbon的IRule进行策略扩展。另外，Feign还整合的Hystrix来实现服务的容错保护，在Dalston版本中，Feign的Hystrix默认是关闭的。待后文介绍Hystrix带领大家入门之后，我们再结合介绍Feign中的Hystrix以及配置方式。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-feign都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-feign服务是如何消费ureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-feign]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Feign</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（Ribbon）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-2%2F</url>
    <content type="text"><![CDATA[通过上一篇《Spring Cloud构建微服务架构：服务消费（基础）》，我们已经学会如何通过LoadBalancerClient接口来获取某个服务的具体实例，并根据实例信息来发起服务接口消费请求。但是这样的做法需要我们手工的去编写服务选取、链接拼接等繁琐的工作，对于开发人员来说非常的不友好。所以，下来我们看看Spring Cloud中针对客户端负载均衡的工具包：Spring Cloud Ribbon。 Spring Cloud RibbonSpring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。 当Ribbon与Eureka联合使用时，ribbonServerList会被DiscoveryEnabledNIWSServerList重写，扩展成从Eureka注册中心中获取服务实例列表。同时它也会用NIWSDiscoveryPing来取代IPing，它将职责委托给Eureka来确定服务端是否已经启动。 而当Ribbon与Consul联合使用时，ribbonServerList会被ConsulServerList来扩展成从Consul获取服务实例列表。同时由ConsulPing来作为IPing接口的实现。 我们在使用Spring Cloud Ribbon的时候，不论是与Eureka还是Consul结合，都会在引入Spring Cloud Eureka或Spring Cloud Consul依赖的时候通过自动化配置来加载上述所说的配置内容，所以我们可以快速在Spring Cloud中实现服务间调用的负载均衡。 下面我们通过具体的例子来看看如何使用Spring Cloud Ribbon来实现服务的调用以及客户端均衡负载。 动手试一试下面的例子，我们将利用之前构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。而基于Spring Cloud Ribbon实现的消费者，我们可以根据eureka-consumer实现的内容进行简单改在就能完成，具体步骤如下： 根据eureka-consumer复制一个服务消费者工程，命名为：eureka-consumer-ribbon。在pom.xml中增加下面的依赖： 1234567&lt;dependencies&gt; ... &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 修改应用主类。为RestTemplate增加@LoadBalanced注解： 123456789101112@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean @LoadBalanced public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。 12345678910@RestControllerpublic class DcController &#123; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; return restTemplate.getForObject("http://eureka-client/dc", String.class); &#125;&#125; 可以看到这里，我们除了去掉了原来与LoadBalancerClient相关的逻辑之外，对于RestTemplate的使用，我们的第一个url参数有一些特别。这里请求的host位置并没有使用一个具体的IP地址和端口的形式，而是采用了服务名的方式组成。那么这样的请求为什么可以调用成功呢？因为Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer-ribbon都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer-ribbon服务是如何消费eureka-client服务的/dc接口的，并且也可以通过启动多个eureka-client服务来观察其负载均衡的效果。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer-ribbon]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务消费（基础）【Dalston版】]]></title>
    <url>%2F2017%2F10%2F17%2Fspring-cloud-starter-dalston-2-1%2F</url>
    <content type="text"><![CDATA[通过上一篇 《Spring Cloud构建微服务架构：服务注册与发现》，我们已经成功地将服务提供者：eureka-client或consul-client注册到了Eureka服务注册中心或Consul服务端上了，同时我们也通过DiscoveryClient接口的getServices获取了当前客户端缓存的所有服务清单，那么接下来我们要学习的就是：如何去消费服务提供者的接口？ 使用LoadBalancerClient在Spring Cloud Commons中提供了大量的与服务治理相关的抽象接口，包括DiscoveryClient、这里我们即将介绍的LoadBalancerClient等。对于这些接口的定义我们在上一篇介绍服务注册与发现时已经说过，Spring Cloud做这一层抽象，很好的解耦了服务治理体系，使得我们可以轻易的替换不同的服务治理设施。 从LoadBalancerClient接口的命名中，我们就知道这是一个负载均衡客户端的抽象定义，下面我们就看看如何使用Spring Cloud提供的负载均衡器客户端接口来实现服务的消费。 下面的例子，我们将利用上一篇中构建的eureka-server作为服务注册中心、eureka-client作为服务提供者作为基础。 我们先来创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖（这里省略了parent和dependencyManagement的配置）： 1234567891011121314&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置application.properties，指定eureka注册中心的地址： 123spring.application.name=eureka-consumerserver.port=2101eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。 1234567891011@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(); &#125; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class).web(true).run(args); &#125;&#125; 创建一个接口用来消费eureka-client提供的接口： 1234567891011121314@RestControllerpublic class DcController &#123; @Autowired LoadBalancerClient loadBalancerClient; @Autowired RestTemplate restTemplate; @GetMapping("/consumer") public String dc() &#123; ServiceInstance serviceInstance = loadBalancerClient.choose("eureka-client"); String url = "http://" + serviceInstance.getHost() + ":" + serviceInstance.getPort() + "/dc"; System.out.println(url); return restTemplate.getForObject(url, String.class); &#125;&#125; 可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用estTemplate对象实现对服务提供者接口的调用。 在完成了上面你的代码编写之后，读者可以将eureka-server、eureka-client、eureka-consumer都启动起来，然后访问http://localhost:2101/consumer ，来跟踪观察eureka-consumer服务是如何消费eureka-client服务的/dc接口的。 consul版的示例，可查看git仓库中的consul-client和consul-consumer更多Spring Cloud内容请持续关注我的博客更新或在《Spring Cloud微服务实战》中获取。 代码示例样例工程将沿用之前在码云和GitHub上创建的SpringCloud-Learning项目，重新做了一下整理。通过不同目录来区分Brixton和Dalston的示例。 码云: 点击查看 GitHub: 点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client eureka的服务消费者：eureka-consumer consul的服务提供方：consul-client consul的服务消费者：consul-consumer 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-2-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Cloud构建微服务架构：服务注册与发现（Eureka、Consul）【Dalston版】]]></title>
    <url>%2F2017%2F09%2F27%2Fspring-cloud-starter-dalston-1%2F</url>
    <content type="text"><![CDATA[Spring Cloud简介Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中涉及的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud0 CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。 微服务架构“微服务架构”在这几年非常的火热，以至于关于微服务架构相关的开源产品被反复的提及（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。 那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。 对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》（中文版翻译点击查看），本文不做更多的介绍和描述。 服务治理在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud来实现服务治理。 由于Spring Cloud为服务治理做了一层抽象接口，所以在Spring Cloud应用中可以支持多种不同的服务治理框架，比如：Netflix Eureka、Consul、Zookeeper。在Spring Cloud服务治理抽象层的作用下，我们可以无缝地切换服务治理实现，并且不影响任何其他的服务注册、服务发现、服务调用等逻辑。 所以，下面我们通过介绍两种服务治理的实现来体会Spring Cloud这一层抽象所带来的好处。 Spring Cloud Eureka首先，我们来尝试使用Spring Cloud Eureka来实现服务治理。 Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。 下面，就来具体看看如何使用Spring Cloud Eureka实现服务治理。 创建“服务注册中心”创建一个基础的Spring Boot工程，命名为eureka-server，并在pom.xml中引入需要的依赖内容：1234567891011121314151617181920212223&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。这一步非常的简单，只需要在一个普通的Spring Boot应用中添加这个注解就能开启此功能，比如下面的例子12345678@EnableEurekaServer@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder(Application.class) .web(true).run(args); &#125;&#125; 在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：12345spring.application.name=eureka-serverserver.port=1001eureka.instance.hostname=localhosteureka.client.register-with-eureka=falseeureka.client.fetch-registry=false 为了与后续要进行注册的服务区分，这里将服务注册中心的端口通过server.port属性设置为1001。启动工程后，访问：http://localhost:1001/，可以看到下面的页面，其中还没有发现任何服务。 创建“服务提供方”下面我们创建提供服务的客户端，并向服务注册中心注册自己。本文我们主要介绍服务的注册与发现，所以我们不妨在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。 首先，创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：123456789101112131415161718192021222324252627&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Dalston.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependencyManagement&gt; 其次，实现/dc请求处理接口，通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。1234567891011@RestControllerpublic class DcController &#123; @Autowired DiscoveryClient discoveryClient; @GetMapping("/dc") public String dc() &#123; String services = "Services: " + discoveryClient.getServices(); System.out.println(services); return services; &#125;&#125; 最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。123456789@EnableDiscoveryClient@SpringBootApplicationpublic class Application &#123; public static void main(String[] args) &#123; new SpringApplicationBuilder( ComputeServiceApplication.class) .web(true).run(args); &#125;&#125; 我们在完成了服务内容的实现之后，再继续对application.properties做一些配置工作，具体如下：123spring.application.name=eureka-clientserver.port=2001eureka.client.serviceUrl.defaultZone=http://localhost:1001/eureka/ 通过spring.application.name属性，我们可以指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问。eureka.client.serviceUrl.defaultZone属性对应服务注册中心的配置内容，指定服务注册中心的位置。为了在本机上测试区分服务提供方和服务注册中心，使用server.port属性设置不同的端口。 启动该工程后，再次访问：http://localhost:1001/。可以如下图内容，我们定义的服务被成功注册了。当然，我们也可以通过直接访问eureka-client服务提供的/dc接口来获取当前的服务清单，只需要访问：http://localhost:2001/dc，我们可以得到如下输出返回：1Services: [eureka-client] 其中，方括号中的eureka-client就是通过Spring Cloud定义的DiscoveryClient接口在eureka的实现中获取到的所有服务清单。由于Spring Cloud在服务发现这一层做了非常好的抽象，所以，对于上面的程序，我们可以无缝的从eureka的服务治理体系切换到consul的服务治理体系中区。 Spring Cloud ConsulSpring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性： 服务发现 健康检查 Key/Value存储 多数据中心由于Spring Cloud Consul项目的实现，我们可以轻松的将基于Spring Boot的微服务应用注册到Consul上，并通过此实现微服务架构中的服务治理。 以之前实现的基于Eureka的示例（eureka-client）为基础，我们如何将之前实现的服务提供者注册到Consul上呢？方法非常简单，我们只需要在pom.xml中将eureka的依赖修改为如下依赖：1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;/artifactId&gt;&lt;/dependency&gt; 接下来再修改一下application.properites，将consul需要的配置信息加入即可，比如：（下面配置是默认值）12spring.cloud.consul.host=localhostspring.cloud.consul.port=8500 到此为止，我们将eureka-client转换为基于consul服务治理的服务提供者就完成了。前文我们已经有提到过服务发现的接口DiscoveryClient是Spring Cloud对服务治理做的一层抽象，所以可以屏蔽Eureka和Consul服务治理的实现细节，我们的程序不需要做任何改变，只需要引入不同的服务治理依赖，并配置相关的配置属性就能轻松的将微服务纳入Spring Cloud的各个服务治理框架中。下面可以尝试让consul的服务提供者运行起来。这里可能读者会问，不需要创建类似eureka-server的服务端吗？由于Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。 我们可以用下面的命令启动consul的开发模式：1234567891011121314151617181920212223242526272829303132$consul agent -dev==&gt; Starting Consul agent...==&gt; Starting Consul agent RPC...==&gt; Consul agent running! Version: &apos;v0.7.2&apos; Node name: &apos;Lenovo-zhaiyc&apos; Datacenter: &apos;dc1&apos; Server: true (bootstrap: false) Client Addr: 127.0.0.1 (HTTP: 8500, HTTPS: -1, DNS: 8600, RPC: 8400) Cluster Addr: 127.0.0.1 (LAN: 8301, WAN: 8302) Gossip encrypt: false, RPC-TLS: false, TLS-Incoming: false Atlas: &lt;disabled&gt;==&gt; Log data will now stream in as it occurs: 2017/06/22 07:50:54 [INFO] raft: Initial configuration (index=1): [&#123;Suffrage:Voter ID:127.0.0.1:8300 Address:127.0.0.1:8300&#125;] 2017/06/22 07:50:54 [INFO] raft: Node at 127.0.0.1:8300 [Follower] entering Follower state (Leader: &quot;&quot;) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding LAN server Lenovo-zhaiyc (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:50:54 [INFO] serf: EventMemberJoin: Lenovo-zhaiyc.dc1 127.0.0.1 2017/06/22 07:50:54 [INFO] consul: Adding WAN server Lenovo-zhaiyc.dc1 (Addr: tcp/127.0.0.1:8300) (DC: dc1) 2017/06/22 07:51:01 [ERR] agent: failed to sync remote state: No cluster leader 2017/06/22 07:51:02 [WARN] raft: Heartbeat timeout from &quot;&quot; reached, starting election 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Candidate] entering Candidate state in term 2 2017/06/22 07:51:02 [DEBUG] raft: Votes needed: 1 2017/06/22 07:51:02 [DEBUG] raft: Vote granted from 127.0.0.1:8300 in term 2. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Election won. Tally: 1 2017/06/22 07:51:02 [INFO] raft: Node at 127.0.0.1:8300 [Leader] entering Leader state 2017/06/22 07:51:02 [INFO] consul: cluster leadership acquired 2017/06/22 07:51:02 [INFO] consul: New leader elected: Lenovo-zhaiyc 2017/06/22 07:51:02 [DEBUG] consul: reset tombstone GC to index 3 2017/06/22 07:51:02 [INFO] consul: member &apos;Lenovo-zhaiyc&apos; joined, marking health alive 2017/06/22 07:51:02 [INFO] agent: Synced service &apos;consul&apos; 2017/06/22 07:51:02 [DEBUG] agent: Node info in sync consul服务端启动完成之后，我们再将之前改造后的consul服务提供者启动起来。consul与eureka一样，都提供了简单的ui界面来查看服务的注册情况： 更多关于Consul的使用指南，读者可查看官方文档：https://www.consul.io/ 代码示例 码云：点击查看 GitHub：点击查看 具体工程说明如下： eureka的服务注册中心：eureka-server eureka的服务提供方：eureka-client consul的服务提供方：consul-client 原作者：程序员didi原文出处：http://blog.didispace.com/spring-cloud-starter-dalston-1/]]></content>
      <categories>
        <category>Spring Cloud</category>
      </categories>
      <tags>
        <tag>Spring Cloud</tag>
        <tag>Eureka</tag>
        <tag>Consul</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring中使用log4j详细配置]]></title>
    <url>%2F2017%2F09%2F26%2Fspring-log4j%2F</url>
    <content type="text"><![CDATA[第一步：导入log4j-1.2.17.jar包。第二步：src同级创建并设置log4j.properties。 log4j.properties的详细配置：123456789101112131415161718192021222324 ### 设置 ###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制抬 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n### 输出DEBUG 级别以上的日志到=E://logs/error.log ###log4j.appender.D = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.D.File = E://logs/log.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUG log4j.appender.D.layout = org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n### 输出ERROR 级别以上的日志到=E://logs/error.log ###log4j.appender.E = org.apache.log4j.DailyRollingFileAppenderlog4j.appender.E.File =E://logs/error.log log4j.appender.E.Append = truelog4j.appender.E.Threshold = ERROR log4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %-d&#123;yyyy-MM-dd HH:mm:ss&#125; [ %t:%r ] - [ %p ] %m%n 更详细的log4j.properties配置 第三步：web.xml中加入配置详细： 1234567891011121314&lt;!-- 设置根目录 --&gt; &lt;!--初始化log4j.properties--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 3000表示 开一条watchdog线程每60秒扫描一下配置文件的变化;这样便于日志存放位置的改变 --&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;3000&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; applicationContext.xml就不需要配置了 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans-3.2.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop-3.2.xsdhttp://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.2.xsd"&gt; &lt;/beans&gt; 然后日志就可以随着spring的启动而启动了。 如果想把日志文件打印到Tomcat日志文件中：log4j.appender.R.File=${catalina.home}/logs/youLogFile.log 这个方法只能Tomcat使用，其它容器就不行了。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>log4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Mysql存入大量TEXT类型的数据报错]]></title>
    <url>%2F2017%2F09%2F26%2Fmysql-text%2F</url>
    <content type="text"><![CDATA[主要的原因是因为max_sort_length的默认值为1024,=解决办法：该参数是动态参数，任何客户端都可以在Mysql数据库运行时更改该参数的值，例如：1.首先应该查询一下这个参数的默认值为多少1mysql&gt; SELECT @@global.max_sort_length; 2.然后去设置这个值： 1mysql&gt; SET GLOBAL max_sort_length=2048; //2048这个数值由你了 3.然后再查询一下这个参数的默认值：1mysql&gt; SELECT @@global.max_sort_length; 以上问题就解决了]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot Mybatis 整合（完整版）]]></title>
    <url>%2F2017%2F09%2F25%2Fspringboot-mybatis%2F</url>
    <content type="text"><![CDATA[本项目使用的环境：1.开发工具：Intellij IDEA 2017.1.32.jdk：1.7.0_793.maven:3.3.9 步骤：1.创建一个springboot项目： 2.创建项目的文件结构以及jdk的版本 3.选择项目所需要的依赖然后点击finish 5.看一下文件的结构： 6.查看一下pom.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.winter&lt;/groupId&gt; &lt;artifactId&gt;springboot-mybatis-demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;springboot-mybatis-demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.7&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.35&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.datatype&lt;/groupId&gt; &lt;artifactId&gt;jackson-datatype-joda&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.module&lt;/groupId&gt; &lt;artifactId&gt;jackson-module-parameter-names&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 分页插件 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- alibaba的druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;$&#123;basedir&#125;/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 7.配置文件 项目不使用application.properties文件 而使用更加简洁的application.yml文件：将原有的resource文件夹下的application.properties文件删除，创建一个新的application.yml配置文件，文件的内容如下：123456789101112131415161718192021222324252627282930313233343536server: port: 8080spring: datasource: name: test url: jdbc:mysql://127.0.0.1:3306/depot username: root password: root # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20mybatis: mapper-locations: classpath:mapping/*.xml type-aliases-package: com.winter.model#pagehelper分页插件pagehelper: helperDialect: mysql reasonable: true supportMethodsArguments: true params: count=countSql 8.创建数据库：12345678CREATE DATABASE mytest;CREATE TABLE t_user( user_id INT NOT NULL PRIMARY KEY AUTO_INCREMENT, user_name VARCHAR(255) NOT NULL , password VARCHAR(255) NOT NULL , phone VARCHAR(255) NOT NULL) ENGINE=INNODB AUTO_INCREMENT=1000 DEFAULT CHARSET=utf8; 9.使用mybatis generator 自动生成代码：a.配置pom.xml中generator 插件所对应的配置文件 ${basedir}/src/main/resources/generator/generatorConfig.xml 123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 数据库驱动:选择你的本地硬盘上面的数据库驱动包--&gt; &lt;classPathEntry location="E:\developer\mybatis-generator-core-1.3.2\lib\mysql-connector-java-5.1.25-bin.jar"/&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;!-- 是否去除自动生成的注释 true：是 ： false:否 --&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库链接URL，用户名、密码 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1/mytest" userId="root" password="root"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver&gt; &lt;property name="forceBigDecimals" value="false"/&gt; &lt;/javaTypeResolver&gt; &lt;!-- 生成模型的包名和位置--&gt; &lt;javaModelGenerator targetPackage="main.java.com.winter.model" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!-- 生成映射文件的包名和位置--&gt; &lt;sqlMapGenerator targetPackage="main.resources.mapping" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成DAO的包名和位置--&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="main.java.com.winter.mapper" targetProject="src"&gt; &lt;property name="enableSubPackages" value="true"/&gt; &lt;/javaClientGenerator&gt; &lt;!-- 要生成的表 tableName是数据库中的表名或视图名 domainObjectName是实体类名--&gt; &lt;table tableName="t_user" domainObjectName="User" enableCountByExample="false" enableUpdateByExample="false" enableDeleteByExample="false" enableSelectByExample="false" selectByExampleQueryId="false"&gt;&lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; b.点击run-Edit Configurations c.添加配置 d.运行 最后生成的文件以及结构： 10.mapper修改 我们还需要修改有点东西，因为生成的类中的路径写了全路径，所以我们要把前面多余的删掉： UserMapper.java12345678910111213141516171819package com.winter.mapper;import com.winter.model.User;public interface UserMapper &#123; int deleteByPrimaryKey(Integer userId); int insert(User record); int insertSelective(User record); User selectByPrimaryKey(Integer userId); int updateByPrimaryKeySelective(User record); int updateByPrimaryKey(User record); //这个方式我自己加的 List&lt;User&gt; selectAllUser();&#125; User.java12345678910111213141516171819202122232425262728293031323334353637383940414243package com.winter.model;public class User &#123; private Integer userId; private String userName; private String password; private String phone; public Integer getUserId() &#123; return userId; &#125; public void setUserId(Integer userId) &#123; this.userId = userId; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName == null ? null : userName.trim(); &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password == null ? null : password.trim(); &#125; public String getPhone() &#123; return phone; &#125; public void setPhone(String phone) &#123; this.phone = phone == null ? null : phone.trim(); &#125;&#125; 对于映射文件xml有一个快捷的方式把所有德多余的代码一次删掉： Ctrl+F 进行搜索“main.java.”: 对于sql语句这种黄色的背景，真心是看不下去了（解决方案）： UserMapper.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" &gt;&lt;mapper namespace="com.winter.mapper.UserMapper" &gt; &lt;resultMap id="BaseResultMap" type="com.winter.model.User" &gt; &lt;id column="user_id" property="userId" jdbcType="INTEGER" /&gt; &lt;result column="user_name" property="userName" jdbcType="VARCHAR" /&gt; &lt;result column="password" property="password" jdbcType="VARCHAR" /&gt; &lt;result column="phone" property="phone" jdbcType="VARCHAR" /&gt; &lt;/resultMap&gt; &lt;sql id="Base_Column_List" &gt; user_id, user_name, password, phone &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;!-- 这个方法是我自己加的 --&gt; &lt;select id="selectAllUser" resultMap="BaseResultMap"&gt; select &lt;include refid="Base_Column_List" /&gt; from t_user &lt;/select&gt; &lt;delete id="deleteByPrimaryKey" parameterType="java.lang.Integer" &gt; delete from t_user where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/delete&gt; &lt;insert id="insert" parameterType="com.winter.model.User" &gt; insert into t_user (user_id, user_name, password, phone) values (#&#123;userId,jdbcType=INTEGER&#125;, #&#123;userName,jdbcType=VARCHAR&#125;, #&#123;password,jdbcType=VARCHAR&#125;, #&#123;phone,jdbcType=VARCHAR&#125;) &lt;/insert&gt; &lt;insert id="insertSelective" parameterType="com.winter.model.User" &gt; insert into t_user &lt;trim prefix="(" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; user_id, &lt;/if&gt; &lt;if test="userName != null" &gt; user_name, &lt;/if&gt; &lt;if test="password != null" &gt; password, &lt;/if&gt; &lt;if test="phone != null" &gt; phone, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides="," &gt; &lt;if test="userId != null" &gt; #&#123;userId,jdbcType=INTEGER&#125;, &lt;/if&gt; &lt;if test="userName != null" &gt; #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id="updateByPrimaryKeySelective" parameterType="com.winter.model.User" &gt; update t_user &lt;set &gt; &lt;if test="userName != null" &gt; user_name = #&#123;userName,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="password != null" &gt; password = #&#123;password,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;if test="phone != null" &gt; phone = #&#123;phone,jdbcType=VARCHAR&#125;, &lt;/if&gt; &lt;/set&gt; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt; &lt;update id="updateByPrimaryKey" parameterType="com.winter.model.User" &gt; update t_user set user_name = #&#123;userName,jdbcType=VARCHAR&#125;, password = #&#123;password,jdbcType=VARCHAR&#125;, phone = #&#123;phone,jdbcType=VARCHAR&#125; where user_id = #&#123;userId,jdbcType=INTEGER&#125; &lt;/update&gt;&lt;/mapper&gt; 11.springboot启动类： 打开类SpringbootMybatisDemoApplication.java，这个是springboot的启动类。我们需要添加点东西： 1234567891011121314package com.winter;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplication@MapperScan("com.winter.mapper")//将项目中对应的mapper类的路径加进来就可以了public class SpringbootMybatisDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootMybatisDemoApplication.class, args); &#125;&#125; 12.测试： 到这里所有的搭建工作都完成了，接下来就是测试的工作，没使用junit4进行测试： 首先看一下完成之后的文件的结构： 13.controller，service层：UserController.java1234567891011121314151617181920212223242526272829303132package com.winter.Controller;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.PathVariable;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.ResponseBody;/** * Created by Administrator on 2017/8/16. */@Controller@RequestMapping(value = "/user")public class UserController &#123; @Autowired private UserService userService; @ResponseBody @RequestMapping(value = "/add", produces = &#123;"application/json;charset=UTF-8"&#125;) public int addUser(User user)&#123; return userService.addUser(user); &#125; @RequestMapping(value = "/all/&#123;pageNum&#125;/&#123;pageSize&#125;", produces = &#123;"application/json;charset=UTF-8"&#125;) public Object findAllUser(@PathVariable("pageNum") int pageNum, @PathVariable("pageSize") int pageSize)&#123; return userService.findAllUser(pageNum,pageSize); &#125;&#125; UserService.java123456789101112131415package com.winter.service;import com.winter.model.User;import java.util.List;/** * Created by Administrator on 2017/8/16. */public interface UserService &#123; int addUser(User user); List&lt;User&gt; findAllUser(int pageNum, int pageSize);&#125; UserServiceImpl.java123456789101112131415161718192021222324252627282930313233343536373839package com.winter.service.impl;import com.github.pagehelper.PageHelper;import com.winter.mapper.UserMapper;import com.winter.model.User;import com.winter.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;/** * Created by Administrator on 2017/8/16. */@Service(value = "userService")public class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper;//这里会报错，但是并不会影响 @Override public int addUser(User user) &#123; return userMapper.insertSelective(user); &#125; /* * 这个方法中用到了我们开头配置依赖的分页插件pagehelper * 很简单，只需要在service层传入参数，然后将参数传递给一个插件的一个静态方法即可； * pageNum 开始页数 * pageSize 每页显示的数据条数 * */ @Override public List&lt;User&gt; findAllUser(int pageNum, int pageSize) &#123; //将参数传给这个方法就可以实现物理分页了，非常简单。 PageHelper.startPage(pageNum, pageSize); return userMapper.selectAllUser(); &#125;&#125; 如果强迫症看不下去那个报错：（解决方法） 14.idea的插件： 可以发http请求的插件： 点击左侧的运行按钮就可以发送请求了；如果返回值正确 说明你已经搭建成功了！！ 源码地址：https://github.com/WinterChenS/springboot-mybatis-demo]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java优雅的输出helloWorld]]></title>
    <url>%2F2017%2F09%2F25%2Fjava-print-helloworld%2F</url>
    <content type="text"><![CDATA[在java中很优雅的输出helloworld，可以试一试1234567891011121314151617public class Test&#123; public static void main(String[] args) &#123; System.out.println(randomString(-229985452) + " " + randomString(-147909649)); &#125; public static String randomString(int seed)&#123; Random rand = new Random(seed); StringBuilder sb = new StringBuilder(); while(true)&#123; int n = rand.nextInt(27); if(n==0) break; sb.append((char)('`'+n)); &#125; return sb.toString(); &#125;&#125;]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
</search>
